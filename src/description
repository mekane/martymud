act_comm.c:   if (ch->pcdata->confirm_delete)
act_comm.c:	    ch->pcdata->confirm_delete = FALSE;
act_comm.c:    	    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
act_comm.c:    ch->pcdata->confirm_delete = TRUE;
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOGOSSIP))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOAUCTION))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOMUSIC))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOQUESTION))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOQUOTE))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOGRATS))
act_comm.c:      if(!IS_SET(ch->comm,COMM_NOWIZ))
act_comm.c:    if (!IS_SET(ch->comm,COMM_SHOUTSOFF))
act_comm.c:    if (!IS_SET(ch->comm,COMM_DEAF))
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:    if (IS_SET(ch->comm,COMM_AFK))
act_comm.c:    if (IS_SET(ch->comm,COMM_SNOOP_PROOF))
act_comm.c:    if (ch->lines != PAGELEN)
act_comm.c:	if (ch->lines)
act_comm.c:	    sprintf(buf,"You display %d lines of scroll.\n\r",ch->lines+2);
act_comm.c:    if (ch->prompt != NULL)
act_comm.c:	sprintf(buf,"Your current prompt is: %s\n\r",ch->prompt);
act_comm.c:    if (IS_SET(ch->comm,COMM_NOSHOUT))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOTELL))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOEMOTE))
act_comm.c:   if (IS_SET(ch->comm,COMM_DEAF))
act_comm.c:     REMOVE_BIT(ch->comm,COMM_DEAF);
act_comm.c:     SET_BIT(ch->comm,COMM_DEAF);
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_QUIET);
act_comm.c:     SET_BIT(ch->comm,COMM_QUIET);
act_comm.c:    if (IS_SET(ch->comm,COMM_AFK))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_AFK);
act_comm.c:     SET_BIT(ch->comm,COMM_AFK);
act_comm.c:    if (buf_string(ch->pcdata->buffer)[0] == '\0')
act_comm.c:    page_to_char(buf_string(ch->pcdata->buffer),ch);
act_comm.c:    clear_buf(ch->pcdata->buffer);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOAUCTION))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOAUCTION);
act_comm.c:	SET_BIT(ch->comm,COMM_NOAUCTION);
act_comm.c:	if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:	if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOAUCTION);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOGOSSIP))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOGOSSIP);
act_comm.c:        SET_BIT(ch->comm,COMM_NOGOSSIP);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_NOGOSSIP);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOGRATS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOGRATS);
act_comm.c:        SET_BIT(ch->comm,COMM_NOGRATS);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_NOGRATS);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOQUOTE))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOQUOTE);
act_comm.c:        SET_BIT(ch->comm,COMM_NOQUOTE);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_NOQUOTE);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOQUESTION))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOQUESTION);
act_comm.c:        SET_BIT(ch->comm,COMM_NOQUESTION);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOQUESTION);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOQUESTION))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOQUESTION);
act_comm.c:        SET_BIT(ch->comm,COMM_NOQUESTION);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOQUESTION);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOMUSIC))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOMUSIC);
act_comm.c:        SET_BIT(ch->comm,COMM_NOMUSIC);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOMUSIC);
act_comm.c:    if (!is_clan(ch) || clan_table[ch->clan].independent)
act_comm.c:      if (IS_SET(ch->comm,COMM_NOCLAN))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOCLAN);
act_comm.c:        SET_BIT(ch->comm,COMM_NOCLAN);
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOCLAN);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOWIZ))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:	SET_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:    REMOVE_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:      	if (IS_SET(ch->comm,COMM_SHOUTSOFF))
act_comm.c:            REMOVE_BIT(ch->comm,COMM_SHOUTSOFF);
act_comm.c:            SET_BIT(ch->comm,COMM_SHOUTSOFF);
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) )
act_comm.c:    REMOVE_BIT(ch->comm,COMM_SHOUTSOFF);
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOTELL) || IS_SET(ch->comm,COMM_DEAF))
act_comm.c:    if ( IS_SET(ch->comm, COMM_QUIET) )
act_comm.c:    if (IS_SET(ch->comm,COMM_DEAF))
act_comm.c:    || ( IS_NPC(victim) && victim->in_room != ch->in_room ) )
act_comm.c:    if ( !(IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL) && !IS_AWAKE(victim) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOTELL) )
act_comm.c:    if ( ( victim = ch->reply ) == NULL )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) )
act_comm.c:	&&   d->character->in_room->area == ch->in_room->area 
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
act_comm.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
act_comm.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_comm.c:	if (vch->desc == NULL || vch == ch)
act_comm.c:	if ((letter = strstr(argument,vch->name)) == NULL)
act_comm.c: 	name = vch->name;
act_comm.c:	    if (*letter == '\'' && matches == strlen(vch->name))
act_comm.c:	    if (*letter == 's' && matches == strlen(vch->name))
act_comm.c: 	    if (matches == strlen(vch->name))
act_comm.c:		if (matches == strlen(vch->name))
act_comm.c:		    name = vch->name;
act_comm.c:	    name = vch->name;
act_comm.c:    level = UMIN( ch->level, sizeof(pose_table) / sizeof(pose_table[0]) - 1 );
act_comm.c:    act( pose_table[pose].message[2*ch->class+0], ch, NULL, NULL, TO_CHAR );
act_comm.c:    act( pose_table[pose].message[2*ch->class+1], ch, NULL, NULL, TO_ROOM );
act_comm.c:    if ( ch->position == POS_FIGHTING )
act_comm.c:    if ( ch->position  < POS_STUNNED  )
act_comm.c:    sprintf( log_buf, "%s has quit.", ch->name );
act_comm.c:    id = ch->id;
act_comm.c:    d = ch->desc;
act_comm.c:	if (tch && tch->id == id)
act_comm.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master != NULL )
act_comm.c:	act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:	if ( ch->master == NULL )
act_comm.c:    REMOVE_BIT(ch->act,PLR_NOFOLLOW);
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    ch->master        = master;
act_comm.c:    ch->leader        = NULL;
act_comm.c:    if ( ch->master == NULL )
act_comm.c:	REMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:    if ( can_see( ch->master, ch ) && ch->in_room != NULL)
act_comm.c:	act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT    );
act_comm.c:    	act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR    );
act_comm.c:    if (ch->master->pet == ch)
act_comm.c:	ch->master->pet = NULL;
act_comm.c:    ch->master = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    if ((pet = ch->pet) != NULL)
act_comm.c:    ch->pet = NULL;
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    	if (ch->master->pet == ch)
act_comm.c:    	    ch->master->pet = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
act_comm.c:	if ( fch->master == ch )
act_comm.c:	if ( fch->leader == ch )
act_comm.c:	    fch->leader = fch;
act_comm.c:	||  (IS_IMMORTAL(victim) && victim->trust >= ch->trust))
act_comm.c:    for ( och = ch->in_room->people; och != NULL; och = och_next )
act_comm.c:	och_next = och->next_in_room;
act_comm.c:	&&   och->master == ch
act_comm.c:	leader = (ch->leader != NULL) ? ch->leader : ch;
act_comm.c:	for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:		    gch->level,
act_comm.c:		    IS_NPC(gch) ? "Mob" : class_table[gch->class].who_name,
act_comm.c:		    gch->hit,   gch->max_hit,
act_comm.c:		    gch->mana,  gch->max_mana,
act_comm.c:		    gch->move,  gch->max_move,
act_comm.c:		    gch->exp    );
act_comm.c:    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
act_comm.c:    if ( ch->gold <  amount_gold || ch->silver < amount_silver)
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:    ch->silver	-= amount_silver;
act_comm.c:    ch->silver	+= share_silver + extra_silver;
act_comm.c:    ch->gold 	-= amount_gold;
act_comm.c:    ch->gold 	+= share_gold + extra_gold;
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:	    gch->gold += share_gold;
act_comm.c:	    gch->silver += share_silver;
act_comm.c:    if ( IS_SET( ch->comm, COMM_NOTELL ) )
act_comm.c:    for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:    if ( ach->leader != NULL ) ach = ach->leader;
act_comm.c:    if ( bch->leader != NULL ) bch = bch->leader;
act_enter.c:	&&   (IS_NPC(ch) || IS_SET(ch->act,ACT_AGGRESSIVE) 
act_enter.c:    if ( ch->fighting != NULL ) 
act_enter.c:        old_room = ch->in_room;
act_enter.c:	portal = get_obj_list( ch, argument,  ch->in_room->contents );
act_enter.c:        if (IS_NPC(ch) && IS_SET(ch->act,ACT_AGGRESSIVE)
act_enter.c:            fch_next = fch->next_in_room;
act_enter.c:            if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM)
act_enter.c:            &&   fch->position < POS_STANDING)
act_enter.c:            if ( fch->master == ch && fch->position == POS_STANDING)
act_enter.c:                if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_enter.c:                &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_enter.c:	    if (ch->in_room == old_room)
act_info.c:    if ( ch->desc == NULL )
act_info.c:	    if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:    if ( !IS_NPC(victim) && !IS_SET(ch->comm, COMM_BRIEF) 
act_info.c:    &&   victim->position == POS_STANDING && ch->on == NULL )
act_info.c:    for ( rch = list; rch != NULL; rch = rch->next_in_room )
act_info.c:	if ( get_trust(ch) < rch->invis_level)
act_info.c:	else if ( room_is_dark( ch->in_room )
act_info.c:    if (!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.c:	if (ch->lines == 0)
act_info.c:		    ch->lines + 2);
act_info.c:        ch->lines = 0;
act_info.c:    ch->lines = lines - 2;
act_info.c:    if (IS_SET(ch->act,PLR_AUTOASSIST))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOEXIT))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOGOLD))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOLOOT))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSAC))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_info.c:    if (IS_SET(ch->comm,COMM_COMPACT))
act_info.c:    if (IS_SET(ch->comm,COMM_PROMPT))
act_info.c:    if (IS_SET(ch->comm,COMM_COMBINE))
act_info.c:    if (!IS_SET(ch->act,PLR_CANLOOT))
act_info.c:    if (IS_SET(ch->act,PLR_NOSUMMON))
act_info.c:    if (IS_SET(ch->act,PLR_NOFOLLOW))
act_info.c:    if (IS_SET(ch->act,PLR_AUTOASSIST))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOASSIST);
act_info.c:      SET_BIT(ch->act,PLR_AUTOASSIST);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOEXIT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOEXIT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOEXIT);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOGOLD))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOGOLD);
act_info.c:      SET_BIT(ch->act,PLR_AUTOGOLD);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOLOOT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOLOOT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOLOOT);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSAC))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOSAC);
act_info.c:      SET_BIT(ch->act,PLR_AUTOSAC);
act_info.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_info.c:      REMOVE_BIT(ch->act,PLR_AUTOSPLIT);
act_info.c:      SET_BIT(ch->act,PLR_AUTOSPLIT);
act_info.c:    if (IS_SET(ch->comm,COMM_BRIEF))
act_info.c:      REMOVE_BIT(ch->comm,COMM_BRIEF);
act_info.c:      SET_BIT(ch->comm,COMM_BRIEF);
act_info.c:    if (IS_SET(ch->comm,COMM_COMPACT))
act_info.c:      REMOVE_BIT(ch->comm,COMM_COMPACT);
act_info.c:      SET_BIT(ch->comm,COMM_COMPACT);
act_info.c:    if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
act_info.c:      REMOVE_BIT(ch->comm,COMM_SHOW_AFFECTS);
act_info.c:      SET_BIT(ch->comm,COMM_SHOW_AFFECTS);
act_info.c:	if (IS_SET(ch->comm,COMM_PROMPT))
act_info.c:      	    REMOVE_BIT(ch->comm,COMM_PROMPT);
act_info.c:      	    SET_BIT(ch->comm,COMM_PROMPT);
act_info.c:   free_string( ch->prompt );
act_info.c:   ch->prompt = str_dup( buf );
act_info.c:   sprintf(buf,"Prompt set to %s\n\r",ch->prompt );
act_info.c:    if (IS_SET(ch->comm,COMM_COMBINE))
act_info.c:      REMOVE_BIT(ch->comm,COMM_COMBINE);
act_info.c:      SET_BIT(ch->comm,COMM_COMBINE);
act_info.c:    if (IS_SET(ch->act,PLR_CANLOOT))
act_info.c:      REMOVE_BIT(ch->act,PLR_CANLOOT);
act_info.c:      SET_BIT(ch->act,PLR_CANLOOT);
act_info.c:  if (IS_SET(ch->act,PLR_NOFOLLOW))
act_info.c:    REMOVE_BIT(ch->act,PLR_NOFOLLOW);
act_info.c:    SET_BIT(ch->act,PLR_NOFOLLOW);
act_info.c:      if (IS_SET(ch->imm_flags,IMM_SUMMON))
act_info.c:	REMOVE_BIT(ch->imm_flags,IMM_SUMMON);
act_info.c:	SET_BIT(ch->imm_flags,IMM_SUMMON);
act_info.c:      if (IS_SET(ch->act,PLR_NOSUMMON))
act_info.c:        REMOVE_BIT(ch->act,PLR_NOSUMMON);
act_info.c:        SET_BIT(ch->act,PLR_NOSUMMON);
act_info.c:    if ( ch->desc == NULL )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    &&   !IS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:    &&   room_is_dark( ch->in_room ) )
act_info.c:	show_char_to_char( ch->in_room->people, ch );
act_info.c:	send_to_char( ch->in_room->name, ch );
act_info.c:	if (IS_IMMORTAL(ch) && (IS_NPC(ch) || IS_SET(ch->act,PLR_HOLYLIGHT)))
act_info.c:	    sprintf(buf," [Room %d]",ch->in_room->vnum);
act_info.c:	|| ( !IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF) ) )
act_info.c:	    send_to_char( ch->in_room->description, ch );
act_info.c:        if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT) )
act_info.c:	show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE );
act_info.c:	show_char_to_char( ch->in_room->people,   ch );
act_info.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_info.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
act_info.c:    pdesc = get_extra_descr(arg3,ch->in_room->extra_descr);
act_info.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
act_info.c:	sprintf(buf,"Obvious exits from room %d:\n\r",ch->in_room->vnum);
act_info.c:	if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_info.c:	    ch->gold,ch->silver);
act_info.c:	ch->gold, ch->silver,ch->exp,
act_info.c:	(ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp);
act_info.c:	ch->name,
act_info.c:	IS_NPC(ch) ? "" : ch->pcdata->title,
act_info.c:	ch->level, get_age(ch),
act_info.c:        ( ch->played + (int) (current_time - ch->logon) ) / 3600);
act_info.c:    if ( get_trust( ch ) != ch->level )
act_info.c:	race_table[ch->race].name,
act_info.c:	ch->sex == 0 ? "sexless" : ch->sex == 1 ? "male" : "female",
act_info.c: 	IS_NPC(ch) ? "mobile" : class_table[ch->class].name);
act_info.c:	ch->hit,  ch->max_hit,
act_info.c:	ch->mana, ch->max_mana,
act_info.c:	ch->move, ch->max_move);
act_info.c:	ch->practice, ch->train);
act_info.c:	ch->carry_number, can_carry_n(ch),
act_info.c:	ch->perm_stat[STAT_STR],
act_info.c:	ch->perm_stat[STAT_INT],
act_info.c:	ch->perm_stat[STAT_WIS],
act_info.c:	ch->perm_stat[STAT_DEX],
act_info.c:	ch->perm_stat[STAT_CON],
act_info.c:	ch->exp,  ch->gold, ch->silver );
act_info.c:    if (!IS_NPC(ch) && ch->level < LEVEL_HERO)
act_info.c:	((ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp));
act_info.c:    sprintf( buf, "Wimpy set to %d hit points.\n\r", ch->wimpy );
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]   > 10 )
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] ==  0 )
act_info.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_HUNGER]   ==  0 )
act_info.c:    switch ( ch->position )
act_info.c:    if (ch->level >= 25)
act_info.c:      if (IS_SET(ch->act,PLR_HOLYLIGHT))
act_info.c:      if (ch->invis_level)
act_info.c:        sprintf( buf, "  Invisible: level %d",ch->invis_level);
act_info.c:      if (ch->incog_level)
act_info.c:	sprintf(buf,"  Incognito: level %d",ch->incog_level);
act_info.c:    if ( ch->level >= 15 )
act_info.c:      if (ch->religion == 0)
act_info.c:	sprintf( buf, "You worship %s.\n\r",(god_table[ch->religion].name));
act_info.c:    if ( ch->level >= 10 )
act_info.c:	sprintf( buf, "Alignment: %d.  ", ch->alignment );
act_info.c:         if ( ch->alignment >  900 ) send_to_char( "angelic.\n\r", ch );
act_info.c:    else if ( ch->alignment >  700 ) send_to_char( "saintly.\n\r", ch );
act_info.c:    else if ( ch->alignment >  350 ) send_to_char( "good.\n\r",    ch );
act_info.c:    else if ( ch->alignment >  100 ) send_to_char( "kind.\n\r",    ch );
act_info.c:    else if ( ch->alignment > -100 ) send_to_char( "neutral.\n\r", ch );
act_info.c:    else if ( ch->alignment > -350 ) send_to_char( "mean.\n\r",    ch );
act_info.c:    else if ( ch->alignment > -700 ) send_to_char( "evil.\n\r",    ch );
act_info.c:    else if ( ch->alignment > -900 ) send_to_char( "demonic.\n\r", ch );
act_info.c:    if (IS_SET(ch->comm,COMM_SHOW_AFFECTS))
act_info.c:    if ( ch->affected != NULL )
act_info.c:	for ( paf = ch->affected; paf != NULL; paf = paf->next )
act_info.c:		if (ch->level >= 20)
act_info.c:	    if ( ch->level >= 20 )
act_info.c:	    if (ch->desc != NULL && ch->desc->connected != CON_PLAYING 
act_info.c:	    &&  		    ch->desc->connected != CON_GEN_GROUPS)
act_info.c:	if (!str_prefix(arg,wch->name))
act_info.c:	    class = class_table[wch->class].who_name;
act_info.c:	    switch(wch->level)
act_info.c:		wch->level,
act_info.c:		wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name
act_info.c:	     wch->incog_level >= LEVEL_HERO ? "(Incog) ": "",
act_info.c: 	     wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
act_info.c:	     clan_table[wch->clan].who_name,
act_info.c:	     IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
act_info.c:             IS_SET(wch->act,PLR_KILLER) ? "(KILLER) " : "",
act_info.c:             IS_SET(wch->act,PLR_THIEF) ? "(THIEF) " : "",
act_info.c:		wch->name, IS_NPC(wch) ? "" : wch->pcdata->title);
act_info.c:        if ( wch->level < iLevelLower
act_info.c:        ||   wch->level > iLevelUpper
act_info.c:        || ( fImmortalOnly  && wch->level < LEVEL_IMMORTAL )
act_info.c:        || ( fClassRestrict && !rgfClass[wch->class] )
act_info.c:        || ( fRaceRestrict && !rgfRace[wch->race])
act_info.c:	|| ( fClanRestrict && !rgfClan[wch->clan]))
act_info.c:	class = class_table[wch->class].who_name;
act_info.c:	switch ( wch->level )
act_info.c:	    wch->level,
act_info.c:	    wch->race < MAX_PC_RACE ? pc_race_table[wch->race].who_name 
act_info.c:	    wch->incog_level >= LEVEL_HERO ? "(Incog) " : "",
act_info.c:	    wch->invis_level >= LEVEL_HERO ? "(Wizi) " : "",
act_info.c:	    clan_table[wch->clan].who_name,
act_info.c:	    IS_SET(wch->comm, COMM_AFK) ? "[AFK] " : "",
act_info.c:            IS_SET(wch->act, PLR_KILLER) ? "(KILLER) " : "",
act_info.c:            IS_SET(wch->act, PLR_THIEF)  ? "(THIEF) "  : "",
act_info.c:	    wch->name,
act_info.c:	    IS_NPC(wch) ? "" : wch->pcdata->title );
act_info.c:    show_list_to_char( ch->carrying, ch, TRUE, TRUE );
act_info.c:	for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:    diff = victim->level - ch->level;
act_info.c:    free_string( ch->pcdata->title );
act_info.c:    ch->pcdata->title = str_dup( buf );
act_info.c:            if (ch->description == NULL || ch->description[0] == '\0')
act_info.c:  	    strcpy(buf,ch->description);
act_info.c:			free_string(ch->description);
act_info.c:			ch->description = str_dup(buf);
act_info.c:			send_to_char( ch->description ? ch->description : 
act_info.c:	    free_string(ch->description);
act_info.c:	    ch->description = str_dup(buf);
act_info.c:	    if ( ch->description != NULL )
act_info.c:		strcat( buf, ch->description );
act_info.c:	free_string( ch->description );
act_info.c:	ch->description = str_dup( buf );
act_info.c:    send_to_char( ch->description ? ch->description : "(None).\n\r", ch );
act_info.c:	ch->hit,  ch->max_hit,
act_info.c:	ch->mana, ch->max_mana,
act_info.c:	ch->move, ch->max_move,
act_info.c:	ch->exp   );
act_info.c:	ch->hit,  ch->max_hit,
act_info.c:	ch->mana, ch->max_mana,
act_info.c:	ch->move, ch->max_move,
act_info.c:	ch->exp   );
act_info.c:	    if ( ch->level < skill_table[sn].skill_level[ch->class] 
act_info.c:	      || ch->pcdata->learned[sn] < 1 /* skill is not known */)
act_info.c:		skill_table[sn].name, ch->pcdata->learned[sn] );
act_info.c:	    ch->practice );
act_info.c:	for ( mob = ch->in_room->people; mob != NULL; mob = mob->next_in_room )
act_info.c:	if ( ch->practice <= 0 )
act_info.c:	&&   (ch->level < skill_table[sn].skill_level[ch->class] 
act_info.c: 	||    ch->pcdata->learned[sn] < 1 /* skill is not known */
act_info.c:	||    skill_table[sn].rating[ch->class] == 0)))
act_info.c:	adept = IS_NPC(ch) ? 100 : class_table[ch->class].skill_adept;
act_info.c:	if ( ch->pcdata->learned[sn] >= adept )
act_info.c:	    ch->practice--;
act_info.c:	    ch->pcdata->learned[sn] += 
act_info.c:	        skill_table[sn].rating[ch->class];
act_info.c:	    if ( ch->pcdata->learned[sn] < adept )
act_info.c:		ch->pcdata->learned[sn] = adept;
act_info.c:	wimpy = ch->max_hit / 5;
act_info.c:    if ( wimpy > ch->max_hit/2 )
act_info.c:    ch->wimpy	= wimpy;
act_info.c:    if ( strcmp( crypt( arg1, ch->pcdata->pwd ), ch->pcdata->pwd ) )
act_info.c:    pwdnew = crypt( arg2, ch->name );
act_info.c:    free_string( ch->pcdata->pwd );
act_info.c:    ch->pcdata->pwd = str_dup( pwdnew );
act_move.c:    in_room = ch->in_room;
act_move.c:    &&   ch->master != NULL
act_move.c:    &&   in_room == ch->master->in_room )
act_move.c:	    	if ( iClass != ch->class
act_move.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	if ( ch->move < move )
act_move.c:	ch->move -= move;
act_move.c:    &&   ch->invis_level < LEVEL_HERO)
act_move.c:    &&   ch->invis_level < LEVEL_HERO)
act_move.c:	fch_next = fch->next_in_room;
act_move.c:	if ( fch->master == ch && IS_AFFECTED(fch,AFF_CHARM) 
act_move.c:	&&   fch->position < POS_STANDING)
act_move.c:	if ( fch->master == ch && fch->position == POS_STANDING 
act_move.c:	    if (IS_SET(ch->in_room->room_flags,ROOM_LAW)
act_move.c:	    &&  (IS_NPC(fch) && IS_SET(fch->act,ACT_AGGRESSIVE)))
act_move.c:	    if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_move.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:	if (ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c: 	ch->on = obj;
act_move.c:    switch ( ch->position )
act_move.c:	    ch->on = NULL;
act_move.c:	ch->position = POS_STANDING;
act_move.c:	    ch->on = NULL;
act_move.c:	ch->position = POS_STANDING;
act_move.c:    if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:    else obj = ch->on;
act_move.c:        if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch ( ch->position )
act_move.c:	ch->position = POS_RESTING;
act_move.c:	ch->position = POS_RESTING;
act_move.c:	ch->position = POS_RESTING;
act_move.c:    if (ch->position == POS_FIGHTING)
act_move.c:	obj = get_obj_list(ch,argument,ch->in_room->contents);
act_move.c:    else obj = ch->on;
act_move.c:	if (obj != NULL && ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	ch->on = obj;
act_move.c:    switch (ch->position)
act_move.c:	    ch->position = POS_SITTING;
act_move.c:	    ch->position = POS_SITTING;
act_move.c:    	    ch->position = POS_SITTING;
act_move.c:    switch ( ch->position )
act_move.c:	if (argument[0] == '\0' && ch->on == NULL)
act_move.c:	    ch->position = POS_SLEEPING;
act_move.c:		obj = ch->on;
act_move.c:	    	obj = get_obj_list( ch, argument,  ch->in_room->contents );
act_move.c:	    if (ch->on != obj && count_users(obj) >= obj->value[0])
act_move.c:	    ch->on = obj;
act_move.c:	    ch->position = POS_SLEEPING;
act_move.c:	af.level     = ch->level; 
act_move.c:	af.duration  = ch->level;
act_move.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
act_move.c:	SET_BIT(ch->affected_by, AFF_HIDE);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE		);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_INVISIBLE	);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK		);
act_move.c:    if (IS_NPC(ch) && !IS_SET(ch->act,ACT_PET))
act_move.c:    if ( ch->in_room == location )
act_move.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
act_move.c:    if ( ( victim = ch->fighting ) != NULL )
act_move.c:	lose = (ch->desc != NULL) ? 25 : 50;
act_move.c:    ch->move /= 2;
act_move.c:    if (ch->pet != NULL)
act_move.c:	do_function(ch->pet, &do_recall, "");
act_move.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
act_move.c:	sprintf( buf, "You have %d training sessions.\n\r", ch->train );
act_move.c:	if ( class_table[ch->class].attr_prime == STAT_STR )
act_move.c:	if ( class_table[ch->class].attr_prime == STAT_INT )
act_move.c:	if ( class_table[ch->class].attr_prime == STAT_WIS )
act_move.c:	if ( class_table[ch->class].attr_prime == STAT_DEX )
act_move.c:	if ( class_table[ch->class].attr_prime == STAT_CON )
act_move.c:	if ( ch->perm_stat[STAT_STR] < get_max_train(ch,STAT_STR)) 
act_move.c:	if ( ch->perm_stat[STAT_INT] < get_max_train(ch,STAT_INT))  
act_move.c:	if ( ch->perm_stat[STAT_WIS] < get_max_train(ch,STAT_WIS)) 
act_move.c:	if ( ch->perm_stat[STAT_DEX] < get_max_train(ch,STAT_DEX))  
act_move.c:	if ( ch->perm_stat[STAT_CON] < get_max_train(ch,STAT_CON))  
act_move.c:		ch->sex == SEX_MALE   ? "big stud" :
act_move.c:		ch->sex == SEX_FEMALE ? "hot babe" :
act_move.c:    	if ( cost > ch->train )
act_move.c:	ch->train -= cost;
act_move.c:        ch->pcdata->perm_hit += 10;
act_move.c:        ch->max_hit += 10;
act_move.c:        ch->hit +=10;
act_move.c:        if ( cost > ch->train )
act_move.c:	ch->train -= cost;
act_move.c:        ch->pcdata->perm_mana += 10;
act_move.c:        ch->max_mana += 10;
act_move.c:        ch->mana += 10;
act_move.c:    if ( ch->perm_stat[stat]  >= get_max_train(ch,stat) )
act_move.c:    if ( cost > ch->train )
act_move.c:    ch->train		-= cost;
act_move.c:    ch->perm_stat[stat]		+= 1;
act_obj.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
act_obj.c:        if (!str_cmp(wch->name,obj->owner))
act_obj.c:    if (!str_cmp(ch->name,owner->name))
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:	for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.c:	    if (gch->on == obj)
act_obj.c:	ch->silver += obj->value[0];
act_obj.c:	ch->gold += obj->value[1];
act_obj.c:        if (IS_SET(ch->act,PLR_AUTOSPLIT))
act_obj.c:    	  for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:	    obj = get_obj_list( ch, arg1, ch->in_room->contents );
act_obj.c:	    for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	    if (ch->silver < amount)
act_obj.c:	    ch->silver -= amount;
act_obj.c:	  if (ch->gold < amount)
act_obj.c:	  ch->gold -= amount;
act_obj.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:	obj_to_room( create_money( gold, silver ), ch->in_room );
act_obj.c:	obj_to_room( obj, ch->in_room );
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:		obj_to_room( obj, ch->in_room );
act_obj.c:	if ( (!silver && ch->gold < amount) || (silver && ch->silver < amount) )
act_obj.c:	    ch->silver		-= amount;
act_obj.c:	    ch->gold		-= amount;
act_obj.c:		ch->reply = victim;
act_obj.c:			amount, silver ? "silver" : "gold",ch->name);
act_obj.c:			change, silver ? "gold" : "silver",ch->name);
act_obj.c:			(95 * amount / 100 - change * 100),ch->name);
act_obj.c:		ch->reply = victim;
act_obj.c:	ch->reply = victim;
act_obj.c:    obj =  get_obj_list(ch,argument,ch->carrying);
act_obj.c:            af.level     = ch->level * percent / 100;
act_obj.c:            af.duration  = ch->level/2 * percent / 100;
act_obj.c:    for ( fountain = ch->in_room->contents; fountain != NULL;
act_obj.c:	for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10 )
act_obj.c:    &&  ch->pcdata->condition[COND_FULL] > 45)
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL]   > 40 )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > 40 )
act_obj.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > 40 )
act_obj.c:	    condition = ch->pcdata->condition[COND_HUNGER];
act_obj.c:	    if ( condition == 0 && ch->pcdata->condition[COND_HUNGER] > 0 )
act_obj.c:	    else if ( ch->pcdata->condition[COND_FULL] > 40 )
act_obj.c:    if ( (ch->level+10) < obj->level )
act_obj.c:	if ( (weapon != NULL && ch->size < SIZE_LARGE &&
act_obj.c:	if ( !IS_NPC(ch) && ch->size < SIZE_LARGE &&
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:       ch->level < skill_table[gsn_dual_wield].skill_level[ch->class] )
act_obj.c:       (ch->size < SIZE_LARGE &&
act_obj.c:  if ( ch->size < SIZE_LARGE &&
act_obj.c:    if ( !ch->religion && !IS_IMMORTAL(ch) )
act_obj.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:    obj = get_obj_list( ch, arg, ch->in_room->contents );
act_obj.c:	for (gch = obj->in_room->people; gch != NULL; gch = gch->next_in_room)
act_obj.c:	    if (gch->on == obj)
act_obj.c:	      god_table[ch->religion].name, silver);
act_obj.c:    ch->silver += silver;
act_obj.c:    if (IS_SET(ch->act,PLR_AUTOSPLIT) )
act_obj.c:	for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:    if (ch->level < obj->level)
act_obj.c:    if ( ch->level < scroll->level)
act_obj.c:	if ( ch->level < staff->level 
act_obj.c:	else for ( vch = ch->in_room->people; vch; vch = vch_next )
act_obj.c:	    vch_next	= vch->next_in_room;
act_obj.c:    if ( arg[0] == '\0' && ch->fighting == NULL )
act_obj.c:	if ( ch->fighting != NULL )
act_obj.c:	    victim = ch->fighting;
act_obj.c: 	if (ch->level < wand->level 
act_obj.c:    if ( ((ch->level + 7 < victim->level || ch->level -7 > victim->level) 
act_obj.c:	REMOVE_BIT(ch->affected_by,AFF_SNEAK);
act_obj.c:	   sprintf( buf, "%s is a lousy thief!", ch->name );
act_obj.c:		    ch->name,(ch->sex == 2) ? "her" : "his");
act_obj.c:	    sprintf( buf,"%s tried to rob me!",ch->name );
act_obj.c:	    sprintf(buf,"Keep your hands out of there, %s!",ch->name);
act_obj.c:		if ( !IS_SET(ch->act, PLR_THIEF) )
act_obj.c:		    SET_BIT(ch->act, PLR_THIEF);
act_obj.c:	gold = victim->gold * number_range(1, ch->level) / MAX_LEVEL;
act_obj.c:	silver = victim->silver * number_range(1,ch->level) / MAX_LEVEL;
act_obj.c:	ch->gold     	+= gold;
act_obj.c:	ch->silver   	+= silver;
act_obj.c:    ||   obj->level > ch->level )
act_obj.c:    if ( ch->carry_number + get_obj_number( obj ) > can_carry_n( ch ) )
act_obj.c:    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
act_obj.c:    for ( keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room )
act_obj.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_KILLER) )
act_obj.c:	sprintf(buf, "%s the KILLER is over here!\n\r", ch->name);
act_obj.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_THIEF) )
act_obj.c:	sprintf(buf, "%s the THIEF is over here!\n\r", ch->name);
act_obj.c:    for (t_obj = ch->carrying; t_obj != NULL; t_obj = t_obj_next)
act_obj.c:	obj->next_content = ch->carrying;
act_obj.c:	ch->carrying = obj;
act_obj.c:    ch->carry_number    += get_obj_number( obj );
act_obj.c:    ch->carry_weight    += get_obj_weight( obj );
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
act_obj.c:	if (ch->in_room->vnum == 9621)
act_obj.c:	    pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:	in_room     = ch->in_room;
act_obj.c:	ch->in_room = pRoomIndexNext;
act_obj.c:	ch->in_room = in_room;
act_obj.c:	if ( ch->pet != NULL )
act_obj.c:	if ( (ch->silver + 100 * ch->gold) < cost )
act_obj.c:	if ( ch->level < pet->level )
act_obj.c:	    pet->description, ch->name );
act_obj.c:	char_to_room( pet, ch->in_room );
act_obj.c:	ch->pet = pet;
act_obj.c:	    ch->reply = keeper;
act_obj.c:	    	ch->reply = keeper;
act_obj.c:	if ( (ch->silver + ch->gold * 100) < cost * number )
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if ( obj->level > ch->level )
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if (ch->carry_number +  number * get_obj_number(obj) > can_carry_n(ch))
act_obj.c:	if ( ch->carry_weight + number * get_obj_weight(obj) > can_carry_w(ch))
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) )
act_obj.c:        if (ch->in_room->vnum == 9621)
act_obj.c:            pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:	ch->reply = keeper;
act_obj.c:    ch->gold     += cost/100;
act_obj.c:    ch->silver 	 += cost - (cost/100) * 100;
act_obj.c:	ch->reply = keeper;
act_obj.c:    ch->reply = keeper;
act_obj.c:  int class = ch->class;
act_obj.c:	ch->level < skill_table[gsn_lore].skill_level[ch->class]) ||
act_wiz.c:      	if (IS_SET(ch->wiznet,WIZ_ON))
act_wiz.c:            REMOVE_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:            SET_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	SET_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	REMOVE_BIT(ch->wiznet,WIZ_ON);
act_wiz.c:	if (!IS_SET(ch->wiznet,WIZ_ON))
act_wiz.c:	    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
act_wiz.c:    if (IS_SET(ch->wiznet,wiznet_table[flag].flag))
act_wiz.c:	REMOVE_BIT(ch->wiznet,wiznet_table[flag].flag);
act_wiz.c:    	SET_BIT(ch->wiznet,wiznet_table[flag].flag);
act_wiz.c:    if (ch->level > 5 || IS_NPC(ch))
act_wiz.c:	    if (ch->pcdata->learned[sn] < 
act_wiz.c:		ch->pcdata->learned[*weapon_table[i].gsn])
act_wiz.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
act_wiz.c:    if (strstr(argument,ch->name) == NULL)
act_wiz.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.c:        if (vch->desc == NULL || vch == ch)
act_wiz.c:        if ((letter = strstr(argument,vch->name)) == NULL)
act_wiz.c:        name = vch->name;
act_wiz.c:            if (*letter == '\'' && matches == strlen(vch->name))
act_wiz.c:            if (*letter == 's' && matches == strlen(vch->name))
act_wiz.c:            if (matches == strlen(vch->name))
act_wiz.c:                if (matches == strlen(vch->name))
act_wiz.c:                    name = vch->name;
act_wiz.c:            name = vch->name;
act_wiz.c:	    sprintf(buf,"Your poofin is %s\n\r",ch->pcdata->bamfin);
act_wiz.c:	if ( strstr(argument,ch->name) == NULL)
act_wiz.c:	free_string( ch->pcdata->bamfin );
act_wiz.c:	ch->pcdata->bamfin = str_dup( argument );
act_wiz.c:        sprintf(buf,"Your poofin is now %s\n\r",ch->pcdata->bamfin);
act_wiz.c:            sprintf(buf,"Your poofout is %s\n\r",ch->pcdata->bamfout);
act_wiz.c:        if ( strstr(argument,ch->name) == NULL)
act_wiz.c:        free_string( ch->pcdata->bamfout );
act_wiz.c:        ch->pcdata->bamfout = str_dup( argument );
act_wiz.c:        sprintf(buf,"Your poofout is now %s\n\r",ch->pcdata->bamfout);
act_wiz.c:	&&   d->character->in_room == ch->in_room )
act_wiz.c:	&&  d->character->in_room != NULL && ch->in_room != NULL
act_wiz.c:	&&  d->character->in_room->area == ch->in_room->area)
act_wiz.c:	location = ch->in_room;
act_wiz.c:    original = ch->in_room;
act_wiz.c:    on = ch->on;
act_wiz.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
act_wiz.c:	    ch->on = on;
act_wiz.c:    for ( rch = location->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:    if ( ch->fighting != NULL )
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:	if (get_trust(rch) >= ch->invis_level)
act_wiz.c:	    if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:		act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if (get_trust(rch) >= ch->invis_level)
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
act_wiz.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
act_wiz.c:    if ( ch->fighting != NULL )
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if (get_trust(rch) >= ch->invis_level)
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:                act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:        if (get_trust(rch) >= ch->invis_level)
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0')
act_wiz.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    if (!is_room_owner(ch,location) && ch->in_room != location 
act_wiz.c:    for ( rch = location->people; rch; rch = rch->next_in_room )
act_wiz.c:	    one_argument( rch->name, buf );
act_wiz.c:        ||   ch->level < obj->level)
act_wiz.c:    if (ch->invis_level < LEVEL_HERO)
act_wiz.c:    	sprintf( buf, "Reboot by %s.", ch->name );
act_wiz.c:    if (ch->invis_level < LEVEL_HERO)
act_wiz.c:    sprintf( buf, "Shutdown by %s.", ch->name );
act_wiz.c:    if (ch->invis_level < LEVEL_HERO)
act_wiz.c:	    if ( d->snoop_by == ch->desc )
act_wiz.c:    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room 
act_wiz.c:    if ( ch->desc != NULL )
act_wiz.c:	for ( d = ch->desc->snoop_by; d != NULL; d = d->snoop_by )
act_wiz.c:    victim->desc->snoop_by = ch->desc;
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original != NULL )
act_wiz.c:    if (!is_room_owner(ch,victim->in_room) && ch->in_room != victim->in_room 
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original  = ch;
act_wiz.c:    victim->desc        = ch->desc;
act_wiz.c:    ch->desc            = NULL;
act_wiz.c:    if (ch->prompt != NULL)
act_wiz.c:        victim->prompt = str_dup(ch->prompt);
act_wiz.c:    victim->comm = ch->comm;
act_wiz.c:    victim->lines = ch->lines;
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original == NULL )
act_wiz.c:    if (ch->prompt != NULL)
act_wiz.c:	free_string(ch->prompt);
act_wiz.c:	ch->prompt = NULL;
act_wiz.c:    sprintf(buf,"$N returns from %s.",ch->short_descr);
act_wiz.c:    wiznet(buf,ch->desc->original,0,WIZ_SWITCHES,WIZ_SECURE,get_trust(ch));
act_wiz.c:    ch->desc->character       = ch->desc->original;
act_wiz.c:    ch->desc->original        = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc; 
act_wiz.c:    ch->desc                  = NULL;
act_wiz.c:	    obj_to_room(clone,ch->in_room);
act_wiz.c:	char_to_room(clone,ch->in_room);
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:	obj_to_room( obj, ch->in_room );
act_wiz.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
act_wiz.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_wiz.c:	  sprintf(buf,"%s tried to purge you!\n\r",ch->name);
act_wiz.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.c:            vch->hit 	= vch->max_hit;
act_wiz.c:            vch->mana	= vch->max_mana;
act_wiz.c:            vch->move	= vch->max_move;
act_wiz.c:        sprintf(buf,"$N restored room %d.",ch->in_room->vnum);
act_wiz.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:	if ( rch->fighting != NULL )
act_wiz.c:	if (IS_NPC(rch) && IS_SET(rch->act,ACT_AGGRESSIVE))
act_wiz.c:	    REMOVE_BIT(rch->act,ACT_AGGRESSIVE);
act_wiz.c:    if (!is_room_owner(ch,location) && ch->in_room != location 
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:            vch_next = vch->next;
act_wiz.c:	    &&	 vch->level < LEVEL_HERO)
act_wiz.c:            vch_next = vch->next;
act_wiz.c:            &&   vch->level >= LEVEL_HERO)
act_wiz.c:	&&  ch->in_room != victim->in_room 
act_wiz.c:      if ( ch->invis_level)
act_wiz.c:	  ch->invis_level = 0;
act_wiz.c:	  ch->invis_level = get_trust(ch);
act_wiz.c:	  ch->reply = NULL;
act_wiz.c:          ch->invis_level = level;
act_wiz.c:      if ( ch->incog_level)
act_wiz.c:          ch->incog_level = 0;
act_wiz.c:          ch->incog_level = get_trust(ch);
act_wiz.c:          ch->reply = NULL;
act_wiz.c:          ch->incog_level = level;
act_wiz.c:    if ( IS_SET(ch->act, PLR_HOLYLIGHT) )
act_wiz.c:	REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	SET_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	if (ch->prefix[0] == '\0')
act_wiz.c:	free_string(ch->prefix);
act_wiz.c:	ch->prefix = str_dup("");
act_wiz.c:    if (ch->prefix[0] != '\0')
act_wiz.c:	free_string(ch->prefix);
act_wiz.c:    ch->prefix = str_dup(argument);
alias.c:    if (ch->prefix[0] != '\0' && str_prefix("prefix",argument))
alias.c:	if (strlen(ch->prefix) + strlen(argument) > MAX_INPUT_LENGTH)
alias.c:	    sprintf(prefix,"%s %s",ch->prefix,argument);
alias.c:    if (IS_NPC(ch) || ch->pcdata->alias[0] == NULL
alias.c:	if (ch->pcdata->alias[alias] == NULL)
alias.c:	if (!str_prefix(ch->pcdata->alias[alias],argument))
alias.c:	    if (!strcmp(ch->pcdata->alias[alias],name))
alias.c:		strcat(buf,ch->pcdata->alias_sub[alias]);
alias.c:    if (ch->desc == NULL)
alias.c:	rch = ch->desc->original ? ch->desc->original : ch;
alias.c:	if (rch->pcdata->alias[0] == NULL)
alias.c:	    if (rch->pcdata->alias[pos] == NULL
alias.c:	    ||	rch->pcdata->alias_sub[pos] == NULL)
alias.c:	    sprintf(buf,"    %s:  %s\n\r",rch->pcdata->alias[pos],
alias.c:		    rch->pcdata->alias_sub[pos]);
alias.c:	    if (rch->pcdata->alias[pos] == NULL
alias.c:	    ||	rch->pcdata->alias_sub[pos] == NULL)
alias.c:	    if (!str_cmp(arg,rch->pcdata->alias[pos]))
alias.c:		sprintf(buf,"%s aliases to '%s'.\n\r",rch->pcdata->alias[pos],
alias.c:			rch->pcdata->alias_sub[pos]);
alias.c:	if (rch->pcdata->alias[pos] == NULL)
alias.c:	if (!str_cmp(arg,rch->pcdata->alias[pos])) /* redefine an alias */
alias.c:	    free_string(rch->pcdata->alias_sub[pos]);
alias.c:	    rch->pcdata->alias_sub[pos] = str_dup(argument);
alias.c:     rch->pcdata->alias[pos]		= str_dup(arg);
alias.c:     rch->pcdata->alias_sub[pos]	= str_dup(argument);
alias.c:    if (ch->desc == NULL)
alias.c:	rch = ch->desc->original ? ch->desc->original : ch;
alias.c:	if (rch->pcdata->alias[pos] == NULL)
alias.c:	    rch->pcdata->alias[pos-1]		= rch->pcdata->alias[pos];
alias.c:	    rch->pcdata->alias_sub[pos-1]	= rch->pcdata->alias_sub[pos];
alias.c:	    rch->pcdata->alias[pos]		= NULL;
alias.c:	    rch->pcdata->alias_sub[pos]		= NULL;
alias.c:	if(!strcmp(arg,rch->pcdata->alias[pos]))
alias.c:	    free_string(rch->pcdata->alias[pos]);
alias.c:	    free_string(rch->pcdata->alias_sub[pos]);
alias.c:	    rch->pcdata->alias[pos] = NULL;
alias.c:	    rch->pcdata->alias_sub[pos] = NULL;
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	    ch->desc = NULL;
comm.c:        if ((victim = ch->fighting) != NULL && can_see(ch,victim))
comm.c:	if (!IS_SET(ch->comm, COMM_COMPACT) )
comm.c:        if ( IS_SET(ch->comm, COMM_PROMPT) )
comm.c:	if (IS_SET(ch->comm,COMM_TELNET_GA))
comm.c:    str = ch->prompt;
comm.c:	    ch->hit,ch->mana,ch->move,ch->prefix);
comm.c:   if (IS_SET(ch->comm,COMM_AFK))
comm.c:		if ((pexit = ch->in_room->exit[door]) != NULL
comm.c:            sprintf( buf2, "%d", ch->hit );
comm.c:            sprintf( buf2, "%d", ch->max_hit );
comm.c:            sprintf( buf2, "%d", ch->mana );
comm.c:            sprintf( buf2, "%d", ch->max_mana );
comm.c:            sprintf( buf2, "%d", ch->move );
comm.c:            sprintf( buf2, "%d", ch->max_move );
comm.c:            sprintf( buf2, "%d", ch->exp );
comm.c:	    (ch->level + 1) * exp_per_level(ch,ch->pcdata->points) - ch->exp);
comm.c:            sprintf( buf2, "%ld", ch->gold);
comm.c:	    sprintf( buf2, "%ld", ch->silver);
comm.c:            if( ch->level > 9 )
comm.c:               sprintf( buf2, "%d", ch->alignment );
comm.c:            if( ch->in_room != NULL )
comm.c:		((!IS_NPC(ch) && IS_SET(ch->act,PLR_HOLYLIGHT)) ||
comm.c:		 (!IS_AFFECTED(ch,AFF_BLIND) && !room_is_dark( ch->in_room )))
comm.c:		? ch->in_room->name : "darkness");
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
comm.c:               sprintf( buf2, "%d", ch->in_room->vnum );
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room != NULL )
comm.c:               sprintf( buf2, "%s", ch->in_room->area->name );
comm.c:   write_to_buffer( ch->desc, buf, point - buf );
comm.c:   if (ch->prefix[0] != '\0')
comm.c:        write_to_buffer(ch->desc,ch->prefix,0);
comm.c:	if (IS_SET(ch->act, PLR_DENY))
comm.c:	if (check_ban(d->host,BAN_PERMIT) && !IS_SET(ch->act,PLR_PERMIT))
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ))
comm.c:	if (check_playing(d,ch->name))
comm.c:	if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:	sprintf( log_buf, "%s@%s has connected.", ch->name, d->host );
comm.c:		if (str_cmp(ch->name,d_old->original ?
comm.c:	    if (check_reconnect(d,ch->name,TRUE))
comm.c:		ch->name, echo_off_str );
comm.c:	pwdnew = crypt( argument, ch->name );
comm.c:	free_string( ch->pcdata->pwd );
comm.c:	ch->pcdata->pwd	= str_dup( pwdnew );
comm.c:	if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:        ch->race = race;
comm.c:	    ch->perm_stat[i] = pc_race_table[race].stats[i];
comm.c:	ch->affected_by = ch->affected_by|race_table[race].aff;
comm.c:	ch->imm_flags	= ch->imm_flags|race_table[race].imm;
comm.c:	ch->res_flags	= ch->res_flags|race_table[race].res;
comm.c:	ch->vuln_flags	= ch->vuln_flags|race_table[race].vuln;
comm.c:	ch->form	= race_table[race].form;
comm.c:	ch->parts	= race_table[race].parts;
comm.c:	ch->pcdata->points = pc_race_table[race].points;
comm.c:	ch->size = pc_race_table[race].size;
comm.c:	case 'm': case 'M': ch->sex = SEX_MALE;    
comm.c:			    ch->pcdata->true_sex = SEX_MALE;
comm.c:	case 'f': case 'F': ch->sex = SEX_FEMALE; 
comm.c:			    ch->pcdata->true_sex = SEX_FEMALE;
comm.c:	       ( pc_race_table[ch->race].class_mult[iClass] > 0) )
comm.c:	     (class_table[iClass].remort_class && !IS_SET(ch->act,PLR_REMORT)))
comm.c:        ch->class = iClass;
comm.c:	sprintf( log_buf, "%s@%s new player.", ch->name, d->host );
comm.c:	    case 'g' : case 'G' : ch->alignment = 750;  break;
comm.c:	    case 'n' : case 'N' : ch->alignment = 0;	break;
comm.c:	    case 'e' : case 'E' : ch->alignment = -750; break;
comm.c:        group_add(ch,class_table[ch->class].base_group,FALSE);
comm.c:        ch->pcdata->learned[gsn_recall] = 50;
comm.c:	    ch->gen_data = new_gen_data();
comm.c:	    ch->gen_data->points_chosen = ch->pcdata->points;
comm.c:	    group_add(ch,class_table[ch->class].default_group,TRUE);
comm.c:		if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.c:	if (weapon == -1 || ch->pcdata->learned[*weapon_table[weapon].gsn] <= 0)
comm.c:                if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.c:	ch->pcdata->learned[*weapon_table[weapon].gsn] = 40;
comm.c:	    if (ch->pcdata->points == pc_race_table[ch->race].points)
comm.c:	    if (ch->pcdata->points <= 40 + pc_race_table[ch->race].points)
comm.c:		    40 + pc_race_table[ch->race].points);
comm.c:	    sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
comm.c:	            exp_per_level(ch,ch->gen_data->points_chosen));
comm.c:	    if (ch->pcdata->points < 40)
comm.c:		ch->train = (40 - ch->pcdata->points + 1) / 2;
comm.c:	    free_gen_data(ch->gen_data);
comm.c:	    ch->gen_data = NULL;
comm.c:                if (ch->pcdata->learned[*weapon_table[i].gsn] > 0)
comm.c:      if ( ch->pcdata->incarnations == 2 )
comm.c:	  int race = ch->race;
comm.c:	    ch->perm_stat[i] = pc_race_table[race].stats[i];
comm.c:	  ch->affected_by = ch->affected_by|race_table[race].aff;
comm.c:	  ch->imm_flags	  = ch->imm_flags|race_table[race].imm;
comm.c:	  ch->res_flags	  = ch->res_flags|race_table[race].res;
comm.c:	  ch->vuln_flags  = ch->vuln_flags|race_table[race].vuln;
comm.c:	  ch->form	  = race_table[race].form;
comm.c:	  ch->parts	  = race_table[race].parts;
comm.c:	  ch->pcdata->points = pc_race_table[race].points;
comm.c:	  ch->size = pc_race_table[race].size;
comm.c:	  ch->class += 5;
comm.c:	  strcat( buf, class_table[ch->class].name );	  
comm.c:	  group_add(ch,class_table[ch->class].base_group,FALSE);
comm.c:	  ch->pcdata->learned[gsn_recall] = 50;
comm.c:	else if ( ch->pcdata->incarnations == 3 )
comm.c:	    ch->race = race;
comm.c:	      ch->perm_stat[i] = pc_race_table[race].stats[i];
comm.c:	    ch->affected_by    = ch->affected_by|race_table[race].aff;
comm.c:	    ch->imm_flags      = ch->imm_flags|race_table[race].imm;
comm.c:	    ch->res_flags      = ch->res_flags|race_table[race].res;
comm.c:	    ch->vuln_flags     = ch->vuln_flags|race_table[race].vuln;
comm.c:	    ch->form	       = race_table[race].form;
comm.c:	    ch->parts	       = race_table[race].parts;
comm.c:	    ch->pcdata->points = pc_race_table[race].points;
comm.c:	    ch->size = pc_race_table[race].size;	    
comm.c:	      ch->class = class_lookup("angel");		  
comm.c:	      ch->alignment = 900;
comm.c:	      ch->class = class_lookup("titan");
comm.c:	      ch->alignment = 0;
comm.c:	      ch->class = class_lookup("demon");
comm.c:	      ch->alignment = -900;
comm.c:	    group_add(ch,class_table[ch->class].base_group,FALSE);
comm.c:	    ch->pcdata->learned[gsn_recall] = 50;
comm.c:        if ( ch->pcdata == NULL || ch->pcdata->pwd[0] == '\0')
comm.c:	ch->next	= char_list;
comm.c:	if ( ch->level == 0 )
comm.c:	    ch->perm_stat[class_table[ch->class].attr_prime] += 3;
comm.c:	    ch->level	= 1;
comm.c:	    ch->exp	= exp_per_level(ch,ch->pcdata->points);
comm.c:	    ch->hit	= ch->max_hit;
comm.c:	    ch->mana	= ch->max_mana;
comm.c:	    ch->move	= ch->max_move;
comm.c:	     ch->train	 = 3;
comm.c:	    ch->train	 += 3;
comm.c:	    ch->practice += 5;
comm.c:		title_table [ch->class] [ch->level]
comm.c:		[ch->sex == SEX_FEMALE ? 1 : 0] );
comm.c:	    switch ( ch->pcdata->incarnations )
comm.c:	    char_to_room( ch, get_room_index(class_table[ch->class].guild[0]));
comm.c:	else if ( ch->in_room != NULL )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:	if (ch->pet != NULL)
comm.c:	  char_to_room(ch->pet,ch->in_room);
comm.c:	  act("$n has entered the game.",ch->pet,NULL,NULL,TO_ROOM);
comm.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
comm.c:	&&   (!fConn || ch->desc == NULL)
comm.c:	&&   !str_cmp( d->character->name, ch->name ) )
comm.c:		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:		sprintf( log_buf, "%s@%s reconnected.", ch->name, d->host );
comm.c:    ||   ch->desc == NULL
comm.c:    ||   ch->desc->connected != CON_PLAYING
comm.c:    ||   ch->was_in_room == NULL 
comm.c:    ||   ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room	= NULL;
comm.c:    if ( txt != NULL && ch->desc != NULL )
comm.c:        write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:    if ( txt == NULL || ch->desc == NULL)
comm.c:    if (ch->lines == 0 )
comm.c:    ch->desc->showstr_head = alloc_mem(strlen(txt) + 1);
comm.c:    strcpy(ch->desc->showstr_head,txt);
comm.c:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:    show_string(ch->desc,"");
comm.c:    if (ch->sex < 0 || ch->sex > 2)
comm.c:    	ch->sex = IS_NPC(ch) ? 0 : ch->pcdata->true_sex;
comm.c:    if (ch == NULL || ch->in_room == NULL)
comm.c:    to = ch->in_room->people;
comm.c:	if (vch->in_room == NULL)
comm.c:        to = vch->in_room->people;
comm.c:		case 'g': i = god_table[ch->religion].name;             break;
db.c:    ch->name			= &str_empty[0];
db.c:    ch->short_descr		= &str_empty[0];
db.c:    ch->long_descr		= &str_empty[0];
db.c:    ch->description		= &str_empty[0];
db.c:    ch->prompt                  = &str_empty[0];
db.c:    ch->logon			= current_time;
db.c:    ch->lines			= PAGELEN;
db.c:    	ch->armor[i]		= 100;
db.c:    ch->position		= POS_STANDING;
db.c:    ch->hit			= 20;
db.c:    ch->max_hit			= 20;
db.c:    ch->mana			= 100;
db.c:    ch->max_mana		= 100;
db.c:    ch->move			= 100;
db.c:    ch->max_move		= 100;
db.c:    ch->on			= NULL;
db.c:	ch->perm_stat[i] = 13; 
db.c:	ch->mod_stat[i] = 0;
db.c:    for (fch = char_list; fch != NULL; fch = fch->next)
db.c:	if (fch->pcdata != NULL)
db.c:	for (af = fch->affected; af != NULL; af = af->next)
db.c:    for (fch = char_free; fch != NULL; fch = fch->next)
db.c:	    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c~:    ch->name			= &str_empty[0];
db.c~:    ch->short_descr		= &str_empty[0];
db.c~:    ch->long_descr		= &str_empty[0];
db.c~:    ch->description		= &str_empty[0];
db.c~:    ch->prompt                  = &str_empty[0];
db.c~:    ch->logon			= current_time;
db.c~:    ch->lines			= PAGELEN;
db.c~:    	ch->armor[i]		= 100;
db.c~:    ch->position		= POS_STANDING;
db.c~:    ch->hit			= 20;
db.c~:    ch->max_hit			= 20;
db.c~:    ch->mana			= 100;
db.c~:    ch->max_mana		= 100;
db.c~:    ch->move			= 100;
db.c~:    ch->max_move		= 100;
db.c~:    ch->on			= NULL;
db.c~:	ch->perm_stat[i] = 13; 
db.c~:	ch->mod_stat[i] = 0;
db.c~:    for (fch = char_list; fch != NULL; fch = fch->next)
db.c~:	if (fch->pcdata != NULL)
db.c~:	for (af = fch->affected; af != NULL; af = af->next)
db.c~:    for (fch = char_free; fch != NULL; fch = fch->next)
db.c~:	    ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
fight.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
fight.c:	ch_next	= ch->next;
fight.c:	if ( ( victim = ch->fighting ) == NULL || ch->in_room == NULL )
fight.c:	if ( IS_AWAKE(ch) && ch->in_room == victim->in_room )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
fight.c:	rch_next = rch->next_in_room;
fight.c:	if (IS_AWAKE(rch) && rch->fighting == NULL)
fight.c:	    && IS_SET(rch->off_flags,ASSIST_PLAYERS)
fight.c:	    &&  rch->level + 6 > victim->level)
fight.c:		if ( ( (!IS_NPC(rch) && IS_SET(rch->act,PLR_AUTOASSIST))
fight.c:		if ( (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALL))
fight.c:		||   (IS_NPC(rch) && rch->group && rch->group == ch->group)
fight.c:		||   (IS_NPC(rch) && rch->race == ch->race 
fight.c:		   && IS_SET(rch->off_flags,ASSIST_RACE))
fight.c:		||   (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALIGN)
fight.c:		||   (rch->pIndexData == ch->pIndexData 
fight.c:		   && IS_SET(rch->off_flags,ASSIST_VNUM)))
fight.c:		    for (vch = ch->in_room->people; vch; vch = vch->next)
fight.c:    if (ch->desc == NULL)
fight.c:	ch->wait = UMAX(0,ch->wait - PULSE_VIOLENCE);
fight.c:    if (ch->desc == NULL)
fight.c:	ch->daze = UMAX(0,ch->daze - PULSE_VIOLENCE); 
fight.c:    if (ch->position < POS_RESTING)
fight.c:    if (ch->fighting != victim)
fight.c:    if ( ch->fighting != victim || dt == gsn_backstab )
fight.c:	if ( ch->fighting != victim )
fight.c:	  if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:    if (ch->fighting != victim)
fight.c:    if (IS_SET(ch->off_flags,OFF_AREA_ATTACK))
fight.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.c:	    vch_next = vch->next;
fight.c:	    if ((vch != victim && vch->fighting == ch))
fight.c:    ||  (IS_SET(ch->off_flags,OFF_FAST) && !IS_AFFECTED(ch,AFF_SLOW)))
fight.c:    if (ch->fighting != victim || dt == gsn_backstab)
fight.c:    if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
fight.c:	if (ch->fighting != victim)
fight.c:    if (IS_AFFECTED(ch,AFF_SLOW) && !IS_SET(ch->off_flags,OFF_FAST))
fight.c:	if (ch->fighting != victim)
fight.c:    if (ch->wait > 0)
fight.c:    if (number == 1 && IS_SET(ch->act,ACT_MAGE))
fight.c:    if (number == 2 && IS_SET(ch->act,ACT_CLERIC))
fight.c:	if (IS_SET(ch->off_flags,OFF_BASH))
fight.c:	if (IS_SET(ch->off_flags,OFF_BERSERK) && !IS_AFFECTED(ch,AFF_BERSERK))
fight.c:	if (IS_SET(ch->off_flags,OFF_DISARM) 
fight.c:	&& (IS_SET(ch->act,ACT_WARRIOR)
fight.c:   	||  IS_SET(ch->act,ACT_THIEF))))
fight.c:	if (IS_SET(ch->off_flags,OFF_KICK))
fight.c:	if (IS_SET(ch->off_flags,OFF_KICK_DIRT))
fight.c:	if (IS_SET(ch->off_flags,OFF_TAIL))
fight.c:	if (IS_SET(ch->off_flags,OFF_TRIP))
fight.c:	if (IS_SET(ch->off_flags,OFF_CRUSH))
fight.c:	if (IS_SET(ch->off_flags,OFF_BACKSTAB))
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:	    dt += ch->dam_type;
fight.c:    	    dam_type = attack_table[ch->dam_type].damage;
fight.c:	if (IS_SET(ch->act,ACT_WARRIOR))
fight.c:	else if (IS_SET(ch->act,ACT_THIEF))
fight.c:	else if (IS_SET(ch->act,ACT_CLERIC))
fight.c:	else if (IS_SET(ch->act,ACT_MAGE))
fight.c:	thac0_00 = class_table[ch->class].thac0_00;
fight.c:	thac0_32 = class_table[ch->class].thac0_32;
fight.c:    thac0  = interpolate( ch->level, thac0_00, thac0_32 );
fight.c:      if ( ch->class == asa ) //assasins get slightly better to-hit with bs
fight.c:    if ( IS_NPC(ch) && (!ch->pIndexData->new_format || wield == NULL))
fight.c:	if (!ch->pIndexData->new_format)
fight.c:	  dam = number_range( ch->level / 2, ch->level * 3 / 2 );
fight.c:	  dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
fight.c:	  dam = number_range( 1 + 4 * skill/100, 2 * ch->level/3 * skill/100);
fight.c:      if ( ch->class == asa )
fight.c:      dam *= 2 + (ch->level / div); 
fight.c:	if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_POISON))
fight.c:    	if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_VAMPIRIC))
fight.c:	  ch->alignment = UMAX(-1000,ch->alignment - 1);
fight.c:	  ch->hit += dam/2;
fight.c:	if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FLAMING))
fight.c:	if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_FROST))
fight.c:	if (ch->fighting == victim && IS_WEAPON_STAT(wield,WEAPON_SHOCKING))
fight.c:	    if ( ch->fighting == NULL )
fight.c:	REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:		(IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:		ch->in_room->vnum );
fight.c:            (IS_NPC(ch) ? ch->short_descr : ch->name),
fight.c:            ch->in_room->name, ch->in_room->vnum);
fight.c:	&&  (corpse = get_obj_list(ch,"corpse",ch->in_room->contents)) != NULL
fight.c:	    corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 
fight.c:	    if ( IS_SET(ch->act, PLR_AUTOLOOT) &&
fight.c: 	    if (IS_SET(ch->act,PLR_AUTOGOLD) &&
fight.c:		!IS_SET(ch->act,PLR_AUTOLOOT))
fight.c:	    if (IS_SET(ch->act, PLR_AUTOSAC))
fight.c:       	        if (IS_SET(ch->act,PLR_AUTOLOOT) && corpse && corpse->contains)
fight.c:    if (victim->in_room == NULL || ch->in_room == NULL)
fight.c:    if (IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL)
fight.c:	    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
fight.c:	    &&  ch->master->fighting != victim)
fight.c:	  if (ch->level > victim->level + 8)
fight.c:    if (victim->in_room == NULL || ch->in_room == NULL)
fight.c:    if (IS_IMMORTAL(ch) && ch->level > LEVEL_IMMORTAL && !area)
fight.c:	  if (area && !is_same_group(victim,ch->fighting))
fight.c:	if (IS_AFFECTED(ch,AFF_CHARM) && ch->master != NULL
fight.c:	    &&  ch->master->fighting != victim)
fight.c:	if (ch->fighting != NULL && !is_same_group(ch->fighting,victim))
fight.c:	if (ch->level > victim->level + 8)
fight.c:  if ( IS_SET(ch->affected_by, AFF_CHARM) )
fight.c:    if ( ch->master == NULL )
fight.c:	       IS_NPC(ch) ? ch->short_descr : ch->name );
fight.c:      REMOVE_BIT( ch->affected_by, AFF_CHARM );
fight.c:      send_to_char( "*** You are now a KILLER!! ***\n\r", ch->master );
fight.c:      SET_BIT(ch->master->act, PLR_KILLER);
fight.c:       ch->level >= LEVEL_IMMORTAL ||
fight.c:       IS_SET(ch->act, PLR_KILLER) ||	 
fight.c:       ch->fighting == victim )
fight.c:  SET_BIT(ch->act, PLR_KILLER);
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( ch->fighting != NULL )
fight.c:    ch->fighting = victim;
fight.c:    ch->position = POS_FIGHTING;
fight.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
fight.c:      if ( fch == ch || ( fBoth && fch->fighting == ch ) )
fight.c:	  fch->fighting	= NULL;
fight.c:	  fch->position	= IS_NPC(fch) ? fch->default_pos : POS_STANDING;
fight.c:      if (IS_SET(ch->form,FORM_UNDEAD))
fight.c:      name		= ch->short_descr;
fight.c:      if ( (ch->gold > 0) || (ch->silver > 0) )
fight.c:	obj_to_obj( create_money( ch->gold, ch->silver ), corpse );
fight.c:	ch->gold = 0;
fight.c:	ch->silver = 0;
fight.c:	name		= ch->name;
fight.c:	REMOVE_BIT(ch->act,PLR_CANLOOT);
fight.c:	    corpse->owner = str_dup(ch->name);
fight.c:	    if (ch->gold > 1 || ch->silver > 1)
fight.c:		obj_to_obj(create_money(ch->gold / 2, ch->silver/2), corpse);
fight.c:		ch->gold -= ch->gold/2;
fight.c:		ch->silver -= ch->silver/2;
fight.c:    corpse->level = ch->level;
fight.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:			obj_to_room(in,ch->in_room);
fight.c:		obj_to_room(obj,ch->in_room);
fight.c:    obj_to_room( corpse, ch->in_room );
fight.c:	if (ch->material == 0)
fight.c:	if (IS_SET(ch->parts,PART_GUTS))
fight.c:	if (IS_SET(ch->parts,PART_HEAD))
fight.c:	if (IS_SET(ch->parts,PART_HEART))
fight.c:	if (IS_SET(ch->parts,PART_ARMS))
fight.c:	if (IS_SET(ch->parts,PART_LEGS))
fight.c:	if (IS_SET(ch->parts,PART_BRAINS))
fight.c:	name		= IS_NPC(ch) ? ch->short_descr : ch->name;
fight.c:	    if (IS_SET(ch->form,FORM_POISON))
fight.c:	    else if (!IS_SET(ch->form,FORM_EDIBLE))
fight.c:	obj_to_room( obj, ch->in_room );
fight.c:    was_in_room = ch->in_room;
fight.c:	    ch->in_room = pexit->u1.to_room;
fight.c:    ch->in_room = was_in_room;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	    group_levels += IS_NPC(gch) ? gch->level / 2 : gch->level;
fight.c:	group_levels = ch->level ;
fight.c:    lch = (ch->leader != NULL) ? ch->leader : ch;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	if ( gch->level - lch->level >= 5 )
fight.c:	if ( gch->level - lch->level <= -5 )
fight.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:		obj_to_room( obj, ch->in_room );
fight.c:    level_range = victim->level - gch->level;
fight.c:    align = victim->alignment - gch->alignment;
fight.c:	change = (align - 500) * base_exp / 500 * gch->level/total_levels; 
fight.c:        gch->alignment = UMAX(-1000,gch->alignment - change);
fight.c:	change =  ( -1 * align - 500) * base_exp/500 * gch->level/total_levels;
fight.c:	gch->alignment = UMIN(1000,gch->alignment + change);
fight.c:	change =  gch->alignment * base_exp/500 * gch->level/total_levels;  
fight.c:	gch->alignment -= change;
fight.c:    else if (gch->alignment > 500)  /* for goodie two shoes */
fight.c:    else if (gch->alignment < -500) /* for baddies */
fight.c:    else if (gch->alignment > 200)  /* a little good */
fight.c:    else if (gch->alignment < -200) /* a little bad */
fight.c:    if (gch->level < 6)
fight.c:      xp = 10 * xp / (gch->level + 4);
fight.c:    //if (gch->level > 35 )
fight.c:    //xp =  15 * xp / (gch->level - 25 );
fight.c:      time_per_level  = 4 *(gch->played+(int)(current_time - gch->logon))/3600;
fight.c:      time_per_level /= gch->level;
fight.c:      if (gch->level < 15)  /* make it a curve */
fight.c:	time_per_level = UMAX(time_per_level,(15 - gch->level));
fight.c:    xp = xp * gch->level/( UMAX(1,total_levels -1) );
fight.c:    ||  (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BERSERK))
fight.c:    &&   ch->level < skill_table[gsn_berserk].skill_level[ch->class]))
fight.c:    if (ch->mana < 50)
fight.c:    if (ch->position == POS_FIGHTING)
fight.c:    hp_percent = 100 * ch->hit/ch->max_hit;
fight.c:	ch->mana -= 50;
fight.c:	ch->move /= 2;
fight.c:	ch->hit += ch->level * 2;
fight.c:	ch->hit = UMIN(ch->hit,ch->max_hit);
fight.c:	af.level	= ch->level;
fight.c:	af.duration	= number_fuzzy(ch->level / 8);
fight.c:	af.modifier	= UMAX(1,ch->level/5);
fight.c:	af.modifier	= UMAX(10,10 * (ch->level/5));
fight.c:	ch->mana -= 25;
fight.c:	ch->move /= 2;
fight.c:    ||	 (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_BASH))
fight.c:    &&	  ch->level < skill_table[gsn_bash].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    chance += ch->carry_weight / 250;
fight.c:    if (ch->size < victim->size)
fight.c:	chance += (ch->size - victim->size) * 15;
fight.c:	chance += (ch->size - victim->size) * 10; 
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:    chance += (ch->level - victim->level);
fight.c:	damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash,
fight.c:	ch->position = POS_RESTING;
fight.c:    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_KICK_DIRT))
fight.c:    &&    ch->level < skill_table[gsn_dirt].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    switch(ch->in_room->sector_type)
fight.c:	af.level 	= ch->level;
fight.c:    ||   (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_TRIP))
fight.c:	  && ch->level < skill_table[gsn_trip].skill_level[ch->class]))
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    if (IS_AFFECTED(ch,AFF_CHARM) || (IS_NPC(ch) && IS_SET(ch->act,ACT_PET)))
fight.c:    if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:	sprintf(buf, "Help! I am being attacked by %s!",ch->short_descr);
fight.c:    	sprintf( buf, "Help!  I am being attacked by %s!", ch->name );
fight.c:  if (ch->fighting != NULL)
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:            ch->position = POS_STANDING;
fight.c:    was_in = ch->in_room;
fight.c:	||   number_range(0,ch->daze) != 0
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:	if( (ch->class == 2) 
fight.c:	    && (number_percent() < 3*(ch->level/2) ) )
fight.c:    if ( ch->fighting == victim )
fight.c:	 ch->level < skill_table[gsn_kick].skill_level[ch->class] )
fight.c:    if (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_KICK))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:	damage(ch,victim,number_range( 1, ch->level ), gsn_kick,DAM_BASH,TRUE);
fight.c:    ||    (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_DISARM))))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    chance += (ch->level - victim->level) * 2;
handler.c:	if (IS_SET(ch->off_flags,ASSIST_PLAYERS))
handler.c:    if (IS_SET(ch->off_flags,ASSIST_ALL))
handler.c:    if (ch->group && ch->group == victim->group)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_VNUM) 
handler.c:    &&  ch->pIndexData == victim->pIndexData)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_RACE) && ch->race == victim->race)
handler.c:    if (IS_SET(ch->off_flags,ASSIST_ALIGN)
handler.c:    &&  !IS_SET(ch->act,ACT_NOALIGN) && !IS_SET(victim->act,ACT_NOALIGN)
handler.c:    for (fch = obj->in_room->people; fch != NULL; fch = fch->next_in_room)
handler.c:	if (fch->on == obj)
handler.c:	if (IS_SET(ch->imm_flags,IMM_WEAPON))
handler.c:	else if (IS_SET(ch->res_flags,RES_WEAPON))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_WEAPON))
handler.c:	if (IS_SET(ch->imm_flags,IMM_MAGIC))
handler.c:	else if (IS_SET(ch->res_flags,RES_MAGIC))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_MAGIC))
handler.c:    if (IS_SET(ch->imm_flags,bit))
handler.c:    else if (IS_SET(ch->res_flags,bit) && immune != IS_IMMUNE)
handler.c:    else if (IS_SET(ch->vuln_flags,bit))
handler.c:    return ch->clan;
handler.c:    if (clan_table[ch->clan].independent)
handler.c:	return (ch->clan == victim->clan);
handler.c:    if (ch->pIndexData == NULL)
handler.c:    else if (ch->pIndexData->new_format)
handler.c:	skill = ch->level * 5 / 2;
handler.c:	if (ch->level < skill_table[sn].skill_level[ch->class])
handler.c:	    skill = ch->pcdata->learned[sn];
handler.c:	    skill = 40 + 2 * ch->level;
handler.c:	    skill = ch->level * 2 + 20;
handler.c:        else if ((sn == gsn_dodge && IS_SET(ch->off_flags,OFF_DODGE))
handler.c: 	||       (sn == gsn_parry && IS_SET(ch->off_flags,OFF_PARRY)))
handler.c:	    skill = ch->level * 2;
handler.c:	    skill = 10 + 2 * ch->level;
handler.c:	&& (IS_SET(ch->act,ACT_WARRIOR) || IS_SET(ch->act,ACT_THIEF)))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	else if (sn == gsn_third_attack && IS_SET(ch->act,ACT_WARRIOR))
handler.c:	    skill = 4 * ch->level - 40;
handler.c:	    skill = 40 + 2 * ch->level;
handler.c: 	else if (sn == gsn_trip && IS_SET(ch->off_flags,OFF_TRIP))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c: 	else if (sn == gsn_bash && IS_SET(ch->off_flags,OFF_BASH))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	     &&  (IS_SET(ch->off_flags,OFF_DISARM) 
handler.c:	     ||   IS_SET(ch->act,ACT_WARRIOR)
handler.c:	     ||	  IS_SET(ch->act,ACT_THIEF)))
handler.c:	    skill = 20 + 3 * ch->level;
handler.c:	else if (sn == gsn_berserk && IS_SET(ch->off_flags,OFF_BERSERK))
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	else if (sn == gsn_backstab && IS_SET(ch->act,ACT_THIEF))
handler.c:	    skill = 20 + 2 * ch->level;
handler.c:	    skill = 40 + ch->level; 
handler.c:	    skill = 40 + ch->level;
handler.c:	    skill = 40 + 5 * ch->level / 2;
handler.c:    if (ch->daze > 0)
handler.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  > 10 )
handler.c:      skill = 3 * ch->level;
handler.c:      skill = 40 + 2 * ch->level;
handler.c:      skill = 40 + 5 * ch->level / 2;
handler.c:      skill = 3 * ch->level;
handler.c:      skill = ch->pcdata->learned[sn];
handler.c:    if (ch->pcdata->perm_hit == 0 
handler.c:    ||	ch->pcdata->perm_mana == 0
handler.c:    ||  ch->pcdata->perm_move == 0
handler.c:    ||	ch->pcdata->last_level == 0)
handler.c:		    case APPLY_SEX:	ch->sex		-= mod;
handler.c:					if (ch->sex < 0 || ch->sex >2)
handler.c:					    ch->sex = IS_NPC(ch) ?
handler.c:						ch->pcdata->true_sex;
handler.c:		    case APPLY_MANA:	ch->max_mana	-= mod;		break;
handler.c:		    case APPLY_HIT:	ch->max_hit	-= mod;		break;
handler.c:		    case APPLY_MOVE:	ch->max_move	-= mod;		break;
handler.c:                    case APPLY_SEX:     ch->sex         -= mod;         break;
handler.c:                    case APPLY_MANA:    ch->max_mana    -= mod;         break;
handler.c:                    case APPLY_HIT:     ch->max_hit     -= mod;         break;
handler.c:                    case APPLY_MOVE:    ch->max_move    -= mod;         break;
handler.c:	ch->pcdata->perm_hit 	= ch->max_hit;
handler.c:	ch->pcdata->perm_mana 	= ch->max_mana;
handler.c:	ch->pcdata->perm_move	= ch->max_move;
handler.c:	ch->pcdata->last_level	= ch->played/3600;
handler.c:	if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.c:	  if (ch->sex > 0 && ch->sex < 3)
handler.c:	    ch->pcdata->true_sex	= ch->sex;
handler.c:	    ch->pcdata->true_sex 	= 0;
handler.c:	ch->mod_stat[stat] = 0;
handler.c:    if (ch->pcdata->true_sex < 0 || ch->pcdata->true_sex > 2)
handler.c:	ch->pcdata->true_sex = 0; 
handler.c:    ch->sex		= ch->pcdata->true_sex;
handler.c:    ch->max_hit 	= ch->pcdata->perm_hit;
handler.c:    ch->max_mana	= ch->pcdata->perm_mana;
handler.c:    ch->max_move	= ch->pcdata->perm_move;
handler.c:    	ch->armor[i]	= 100;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->saving_throw	= 0;
handler.c:	    ch->armor[i] -= apply_ac( obj, loc, i );
handler.c:		case APPLY_STR:		ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:		case APPLY_DEX:		ch->mod_stat[STAT_DEX]	+= mod; break;
handler.c:		case APPLY_INT:		ch->mod_stat[STAT_INT]	+= mod; break;
handler.c:		case APPLY_WIS:		ch->mod_stat[STAT_WIS]	+= mod; break;
handler.c:		case APPLY_CON:		ch->mod_stat[STAT_CON]	+= mod; break;
handler.c:		case APPLY_SEX:		ch->sex			+= mod; break;
handler.c:		case APPLY_MANA:	ch->max_mana		+= mod; break;
handler.c:		case APPLY_HIT:		ch->max_hit		+= mod; break;
handler.c:		case APPLY_MOVE:	ch->max_move		+= mod; break;
handler.c:			ch->armor[i] += mod; 
handler.c:		case APPLY_HITROLL:	ch->hitroll		+= mod; break;
handler.c:		case APPLY_DAMROLL:	ch->damroll		+= mod; break;
handler.c:		case APPLY_SAVES:		ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_ROD: 		ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_PETRI:	ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_BREATH: 	ch->saving_throw += mod; break;
handler.c:		case APPLY_SAVING_SPELL:	ch->saving_throw += mod; break;
handler.c:                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
handler.c:                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
handler.c:                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
handler.c:                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
handler.c:                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
handler.c:                case APPLY_SEX:         ch->sex                 += mod; break;
handler.c:                case APPLY_MANA:        ch->max_mana            += mod; break;
handler.c:                case APPLY_HIT:         ch->max_hit             += mod; break;
handler.c:                case APPLY_MOVE:        ch->max_move            += mod; break;
handler.c:                        ch->armor[i] += mod;
handler.c:		case APPLY_HITROLL:     ch->hitroll             += mod; break;
handler.c:                case APPLY_DAMROLL:     ch->damroll             += mod; break;
handler.c:                case APPLY_SAVES:         ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
handler.c:    for (af = ch->affected; af != NULL; af = af->next)
handler.c:                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
handler.c:                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
handler.c:                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
handler.c:                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
handler.c:                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
handler.c:                case APPLY_SEX:         ch->sex                 += mod; break;
handler.c:                case APPLY_MANA:        ch->max_mana            += mod; break;
handler.c:                case APPLY_HIT:         ch->max_hit             += mod; break;
handler.c:                case APPLY_MOVE:        ch->max_move            += mod; break;
handler.c:                        ch->armor[i] += mod;
handler.c:                case APPLY_HITROLL:     ch->hitroll             += mod; break;
handler.c:                case APPLY_DAMROLL:     ch->damroll             += mod; break;
handler.c:                case APPLY_SAVES:         ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_ROD:          ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_PETRI:        ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_BREATH:       ch->saving_throw += mod; break;
handler.c:                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
handler.c:    if (ch->sex < 0 || ch->sex > 2)
handler.c:	ch->sex = ch->pcdata->true_sex;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c:	ch = ch->desc->original;
handler.c:    if (ch->trust)
handler.c:	return ch->trust;
handler.c:    if ( IS_NPC(ch) && ch->level >= LEVEL_HERO )
handler.c:	return ch->level;
handler.c:  return 17 + ( ch->played + (int) (current_time - ch->logon) ) / 72000;
handler.c:    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
handler.c:	max = pc_race_table[ch->race].max_stats[stat] + 4;
handler.c:	if (class_table[ch->class].attr_prime == stat)
handler.c:	if ( ch->race == race_lookup("human"))
handler.c:    return URANGE(3,ch->perm_stat[stat] + ch->mod_stat[stat], max);
handler.c:    if (IS_NPC(ch) || ch->level > LEVEL_IMMORTAL)
handler.c:    max = pc_race_table[ch->race].max_stats[stat];
handler.c:    if (class_table[ch->class].attr_prime == stat)
handler.c:      if (ch->race == race_lookup("human"))
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return MAX_WEAR +  2 * get_curr_stat(ch,STAT_DEX) + ch->level;
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    return str_app[get_curr_stat(ch,STAT_STR)].carry * 10 + ch->level * 25;
handler.c:	    SET_BIT(ch->affected_by, paf->bitvector);
handler.c:            SET_BIT(ch->affected2_by, paf->bitvector);
handler.c:	    SET_BIT(ch->imm_flags,paf->bitvector);
handler.c:	    SET_BIT(ch->res_flags,paf->bitvector);
handler.c:	    SET_BIT(ch->vuln_flags,paf->bitvector);
handler.c:            REMOVE_BIT(ch->affected_by, paf->bitvector);
handler.c:	    REMOVE_BIT(ch->affected2_by, paf->bitvector);
handler.c:            REMOVE_BIT(ch->imm_flags,paf->bitvector);
handler.c:            REMOVE_BIT(ch->res_flags,paf->bitvector);
handler.c:            REMOVE_BIT(ch->vuln_flags,paf->bitvector);
handler.c:    case APPLY_STR:           ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:    case APPLY_DEX:           ch->mod_stat[STAT_DEX]	+= mod;	break;
handler.c:    case APPLY_INT:           ch->mod_stat[STAT_INT]	+= mod;	break;
handler.c:    case APPLY_WIS:           ch->mod_stat[STAT_WIS]	+= mod;	break;
handler.c:    case APPLY_CON:           ch->mod_stat[STAT_CON]	+= mod;	break;
handler.c:    case APPLY_SEX:           ch->sex			+= mod;	break;
handler.c:    case APPLY_MANA:          ch->max_mana		+= mod;	break;
handler.c:    case APPLY_HIT:           ch->max_hit		+= mod;	break;
handler.c:    case APPLY_MOVE:          ch->max_move		+= mod;	break;
handler.c:            ch->armor[i] += mod;
handler.c:    case APPLY_HITROLL:       ch->hitroll		+= mod;	break;
handler.c:    case APPLY_DAMROLL:       ch->damroll		+= mod;	break;
handler.c:    case APPLY_SAVES:         ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_ROD:    ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_PETRI:  ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_BREATH: ch->saving_throw		+= mod;	break;
handler.c:    case APPLY_SAVING_SPELL:  ch->saving_throw		+= mod;	break;
handler.c:	    obj_to_room( wield, ch->in_room );
handler.c:    for (paf = ch->affected; paf != NULL; paf = paf->next)
handler.c:		    SET_BIT(ch->affected_by,vector);
handler.c:                    SET_BIT(ch->affected2_by, vector);
handler.c:		    SET_BIT(ch->imm_flags,vector);   
handler.c:		    SET_BIT(ch->res_flags,vector);
handler.c:		    SET_BIT(ch->vuln_flags,vector);
handler.c:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content)
handler.c:		    SET_BIT(ch->affected_by,vector);
handler.c:                    SET_BIT(ch->affected2_by, vector);
handler.c:		    SET_BIT(ch->imm_flags,vector);
handler.c:		    SET_BIT(ch->res_flags,vector);
handler.c:		    SET_BIT(ch->vuln_flags,vector);
handler.c:                        SET_BIT(ch->affected_by,vector);
handler.c:                        SET_BIT(ch->affected2_by, vector);
handler.c:                        SET_BIT(ch->imm_flags,vector);
handler.c:                        SET_BIT(ch->res_flags,vector);
handler.c:                        SET_BIT(ch->vuln_flags,vector);
handler.c:    paf_new->next	= ch->affected;
handler.c:    ch->affected	= paf_new;
handler.c:    if ( ch->affected == NULL )
handler.c:    if ( paf == ch->affected )
handler.c:	ch->affected	= paf->next;
handler.c:	for ( prev = ch->affected; prev != NULL; prev = prev->next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    for ( paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next )
handler.c:    if ( ch->in_room == NULL )
handler.c:	--ch->in_room->area->nplayer;
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    if ( ch == ch->in_room->people )
handler.c:	ch->in_room->people = ch->next_in_room;
handler.c:	for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:		prev->next_in_room = ch->next_in_room;
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->on 	     = NULL;  /* sanity check! */
handler.c:    ch->in_room		= pRoomIndex;
handler.c:    ch->next_in_room	= pRoomIndex->people;
handler.c:	if (ch->in_room->area->empty)
handler.c:	    ch->in_room->area->empty = FALSE;
handler.c:	    ch->in_room->area->age = 0;
handler.c:	++ch->in_room->area->nplayer;
handler.c:	++ch->in_room->light;
handler.c:        for ( af = ch->affected; af != NULL; af = af->next )
handler.c:            REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
handler.c:        for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
handler.c:    obj->next_content	 = ch->carrying;
handler.c:    ch->carrying	 = obj;
handler.c:    ch->carry_number	+= get_obj_number( obj );
handler.c:    ch->carry_weight	+= get_obj_weight( obj );
handler.c:    if ( ch->carrying == obj )
handler.c:	ch->carrying = obj->next_content;
handler.c:	for ( prev = ch->carrying; prev != NULL; prev = prev->next_content )
handler.c:    ch->carry_number	-= get_obj_number( obj );
handler.c:    ch->carry_weight	-= get_obj_weight( obj );
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	obj_to_room( obj, ch->in_room );
handler.c:    	ch->armor[i]      	-= apply_ac( obj, iWear,i );
handler.c:    &&   ch->in_room != NULL )
handler.c:	++ch->in_room->light;
handler.c:      ch->armor[i]	+= apply_ac( obj, obj->wear_loc,i );
handler.c:	  for ( lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next )
handler.c:	for ( lpaf = ch->affected; lpaf != NULL; lpaf = lpaf_next )
handler.c:    &&   ch->in_room != NULL
handler.c:    &&   ch->in_room->light > 0 )
handler.c:	--ch->in_room->light;
handler.c:    for (ch = in_room->people; ch != NULL; ch = ch->next_in_room)
handler.c:	if (ch->on == obj)
handler.c:	    ch->on = NULL;
handler.c:    if ( ch->in_room == NULL )
handler.c:    ch->pet = NULL; /* just in case */
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
handler.c:    if (ch->in_room != NULL)
handler.c:        char_to_room(ch,get_room_index(clan_table[ch->clan].hall));
handler.c:	--ch->pIndexData->count;
handler.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
handler.c:	ch->desc = NULL;
handler.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
handler.c:	if ( wch->reply == ch )
handler.c:	    wch->reply = NULL;
handler.c:       char_list = ch->next;
handler.c:		prev->next = ch->next;
handler.c:    if ( ch->desc != NULL )
handler.c:	ch->desc->character = NULL;
handler.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
handler.c:	if ( !can_see( ch, rch ) || !is_name( arg, rch->name ) )
handler.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
handler.c:	if ( wch->in_room == NULL || !can_see( ch, wch ) 
handler.c:	||   !is_name( arg, wch->name ) )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.c:    silver = UMIN(ch->silver,cost); 
handler.c:    ch->gold -= gold;
handler.c:    ch->silver -= silver;
handler.c:    if (ch->gold < 0)
handler.c:	bug("deduct costs: gold %d < 0",ch->gold);
handler.c:	ch->gold = 0;
handler.c:    if (ch->silver < 0)
handler.c:	bug("deduct costs: silver %d < 0",ch->silver);
handler.c:	ch->silver = 0;
handler.c:    return is_name(ch->name,room->owner);
handler.c:    for ( rch = pRoomIndex->people; rch != NULL; rch = rch->next_in_room )
handler.c:    &&  ch->level > 5 && !IS_IMMORTAL(ch))
handler.c:    if (!IS_IMMORTAL(ch) && pRoomIndex->clan && ch->clan != pRoomIndex->clan)
handler.c:    if (get_trust(ch) < victim->incog_level && ch->in_room != victim->in_room)
handler.c:    if ( (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT)) 
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_INFRARED) )
handler.c:	chance -= ch->level - victim->level * 3/2;
handler.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT) )
handler.c:    if ( room_is_dark( ch->in_room ) && !IS_AFFECTED(ch, AFF_DARK_VISION) )
handler.c:    if ( !IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL )
healer.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
healer.c:    if (cost > (ch->gold * 100 + ch->silver))
healer.c:	ch->mana += dice(2,8) + mob->level / 3;
healer.c:	ch->mana = UMIN(ch->mana,ch->max_mana);
interp.c:    REMOVE_BIT( ch->affected_by, AFF_HIDE );
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->act, PLR_FREEZE) )
interp.c:    if ( ( !IS_NPC(ch) && IS_SET(ch->act, PLR_LOG) )
interp.c:	sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    if ( ch->desc != NULL && ch->desc->snoop_by != NULL )
interp.c:	write_to_buffer( ch->desc->snoop_by, "% ",    2 );
interp.c:	write_to_buffer( ch->desc->snoop_by, logline, 0 );
interp.c:	write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
interp.c:    if ( ch->position < cmd_table[cmd].position )
interp.c:	switch( ch->position )
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
interp.c:    switch ( ch->position )
magic.c:	    if (ch->level >= skill_table[sn].skill_level[ch->class]
magic.c:	    &&  ch->pcdata->learned[sn] > 0)
magic.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
magic.c:	    act((!IS_NPC(rch) && ch->class==rch->class) ? buf : buf2,
magic.c:    if (ch->level + 2 == level)
magic.c:    return UMAX(min_mana,(100/(2 + ch->level - level)));
magic.c:    if ( IS_NPC(ch) && ch->desc == NULL)
magic.c:    || (!IS_NPC(ch) && (ch->level < skill_table[sn].skill_level[ch->class]
magic.c:    ||   		 ch->pcdata->learned[sn] == 0)))
magic.c:    if ( ch->position < skill_table[sn].minimum_position )
magic.c:    if ( (ch->class == cle || ch->class == pre) && (!ch->religion) &&
magic.c:    if (ch->level + 2 == skill_table[sn].skill_level[ch->class])
magic.c:	    100 / ( 2 + ch->level - skill_table[sn].skill_level[ch->class] ) );
magic.c:	    if ( ( victim = ch->fighting ) == NULL )
magic.c:        if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:	if ( arg2[0] != '\0' && !is_name( target_name, ch->name ) )
magic.c:	    if ((victim = ch->fighting) == NULL)
magic.c:            if ( IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim )
magic.c:    if ( !IS_NPC(ch) && ch->mana < mana )
magic.c:	ch->mana -= mana / 2;
magic.c:      if (IS_NPC(ch) || class_table[ch->class].fMana)
magic.c:	lvl = ch->level;
magic.c:	lvl = 3 * ch->level / 4;
magic.c:      if ( (ch->class == cle) || (ch->class == pre) )
magic.c:		 || symbol->pIndexData->vnum != god_table[ch->religion].symbol)
magic.c:	if ( ch->in_room->vnum == god_table[ch->religion].temple )
magic.c:      if ( (ch->class == wiz) || (ch->class == pre) )
magic.c:      ch->mana -= mana;
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:	    victim = ch->fighting;
magic.c:	  if (ch->fighting != NULL)
magic.c:	    victim = ch->fighting;
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	    vch_next = vch->next_in_room;
magic.c:	 !(IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim) ) ||
magic.c:    disc->value[0]	= ch->level * 10; /* 10 pounds per level capacity */
magic.c:    disc->value[3]	= ch->level * 5; /* 5 pounds per level max per item */
magic.c:    disc->timer		= ch->level * 2 - number_range(0,level / 2); 
magic.c:    from_room = ch->in_room;
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    obj_to_room(portal,ch->in_room);
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_SAFE)
magic.c:    char_to_room( victim, ch->in_room );
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:      if (vch->position == POS_FIGHTING)
magic.c:	  mlevel += vch->level;
magic.c:	  mlevel += vch->level/2;
magic.c:	high_level = UMAX(high_level,vch->level);
magic.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	    if (IS_NPC(vch) && (IS_SET(vch->imm_flags,IMM_MAGIC) ||
magic.c:				IS_SET(vch->act,ACT_UNDEAD)))
magic.c:	    if (vch->fighting || vch->position == POS_FIGHTING)
magic.c:	for (tmp_vict = ch->in_room->people; 
magic.c:    obj_to_room( light, ch->in_room );
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room )
magic.c:      if (!is_exact_name( speaker, vch->name) && IS_AWAKE(vch))
magic.c:  if( ch->pet != NULL )
magic.c:  char_to_room( mob, ch->in_room );
magic.c:  ch->pet = mob;
magic.c:        ch->alignment = UMAX(-1000, ch->alignment - 20);
magic.c:      dam		 = ch->hit + 1;
magic.c:      ch->hit		+= dam;
magic.c:        ch->alignment = UMAX(-1000, ch->alignment - 50);
magic.c:	dam		 = ch->hit + 1;
magic.c:	ch->hit		+= dam;
magic.c:    hpch = UMAX(12,ch->hit);
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting != vch || vch->fighting != ch)))
magic.c:    hpch = UMAX(12,ch->hit);
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting != vch || vch->fighting != ch)))
magic.c:    hpch = UMAX(16,ch->hit);
magic.c:    poison_effect(ch->in_room,level,dam,TARGET_ROOM);
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
magic.c:	vch_next = vch->next_in_room;
magic.c:	&&   (ch->fighting == vch || vch->fighting == ch)))
magic.c:    hpch = UMAX(10,ch->hit);
magic_clerical.c:    ch->alignment = UMAX(-1000, ch->alignment - 50);
magic_clerical.c:    if (victim->hit > (ch->level * 4))
magic_clerical.c:    if (victim->hit > (ch->level * 4))
magic_clerical.c:	vch_next	= vch->next;
magic_clerical.c:	if ( vch->in_room == NULL )
magic_clerical.c:	if ( vch->in_room == ch->in_room )
magic_clerical.c:	if ( vch->in_room->area == ch->in_room->area )
magic_clerical.c:	    ch->saving_throw -= 1;
magic_clerical.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic_clerical.c:        vch_next = vch->next_in_room;
magic_clerical.c:    ch->move = 0;
magic_clerical.c:    ch->hit /= 2;
magic_clerical.c:    obj_to_room( mushroom, ch->in_room );
magic_clerical.c:    obj_to_room( spring, ch->in_room );
magic_clerical.c:	||   ch->level < obj->level)
magic_clerical.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic_clerical.c:	    ch->saving_throw += 1;
magic_clerical.c:  obj_to_room( berry, ch->in_room );
magic_clerical.c:	vch_next	= vch->next;
magic_clerical.c:	if ( vch->in_room == NULL )
magic_clerical.c:	if ( vch->in_room == ch->in_room )
magic_clerical.c:	if ( vch->in_room->area == ch->in_room->area
magic_clerical.c:    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
magic_clerical.c:	if (ich->invis_level > 0)
magic_clerical.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic_clerical.c:	REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE	);
magic_clerical.c:	REMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic_clerical.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic_clerical.c:    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic_clerical.c:	act("$n steps through a gate and vanishes.",ch->pet,NULL,NULL,TO_ROOM);
magic_clerical.c:	send_to_char("You step through a gate and vanish.\n\r",ch->pet);
magic_clerical.c:	char_from_room(ch->pet);
magic_clerical.c:	char_to_room(ch->pet,victim->in_room);
magic_clerical.c:	act("$n has arrived through a gate.",ch->pet,NULL,NULL,TO_ROOM);
magic_clerical.c:	do_function(ch->pet, &do_look, "auto");
magic_clerical.c:    ch->move /= 2;
merc.h:#define IS_GOOD(ch)		(ch->alignment >= 350)
merc.h:#define IS_EVIL(ch)		(ch->alignment <= -350)
merc.h:#define IS_AWAKE(ch)		(ch->position > POS_SLEEPING)
music.c:    for (juke = ch->in_room->contents; juke != NULL; juke = juke->next_content)
note.c:    if ( !str_cmp( ch->name, pnote->sender ) )
note.c:    if (ch->clan && is_exact_name(clan_table[ch->clan].name,pnote->to_list))
note.c:    if (is_exact_name( ch->name, pnote->to_list ) )
note.c:    if ( ch->pnote != NULL )
note.c:    pnote->sender	= str_dup( ch->name );
note.c:    ch->pnote		= pnote;
note.c:    	    if ( to_one[0] != '\0' && str_cmp( ch->name, to_one ) )
note.c:       if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\0' )
note.c:	    last_read = ch->pcdata->last_note;
note.c:	    last_read = ch->pcdata->last_idea;
note.c:	    last_read = ch->pcdata->last_penalty;
note.c:	    last_read = ch->pcdata->last_news;
note.c:	    last_read = ch->pcdata->last_changes;
note.c:    if (!str_cmp(ch->name,pnote->sender))
note.c:	    ch->pcdata->last_note = UMAX(ch->pcdata->last_note,stamp);
note.c:	    ch->pcdata->last_idea = UMAX(ch->pcdata->last_idea,stamp);
note.c:	    ch->pcdata->last_penalty = UMAX(ch->pcdata->last_penalty,stamp);
note.c:	    ch->pcdata->last_news = UMAX(ch->pcdata->last_news,stamp);
note.c:	    ch->pcdata->last_changes = UMAX(ch->pcdata->last_changes,stamp);
note.c:		ch->pcdata->last_note = current_time;
note.c:		ch->pcdata->last_idea = current_time;
note.c:		ch->pcdata->last_penalty = current_time;
note.c:		ch->pcdata->last_news = current_time;
note.c:		ch->pcdata->last_changes = current_time;
note.c:	if (ch->pnote->type != type)
note.c:	if (strlen(ch->pnote->text)+strlen(argument) >= 4096)
note.c:	add_buf(buffer,ch->pnote->text);
note.c:	free_string( ch->pnote->text );
note.c:	ch->pnote->text = str_dup( buf_string(buffer) );
note.c:        if (ch->pnote->type != type)
note.c:	if (ch->pnote->text == NULL || ch->pnote->text[0] == '\0')
note.c:	strcpy(buf,ch->pnote->text);
note.c:		    free_string(ch->pnote->text);
note.c:		    ch->pnote->text = str_dup(buf);
note.c:	free_string(ch->pnote->text);
note.c:	ch->pnote->text = str_dup(buf);
note.c:        if (ch->pnote->type != type)
note.c:	free_string( ch->pnote->subject );
note.c:	ch->pnote->subject = str_dup( argument );
note.c:        if (ch->pnote->type != type)
note.c:	free_string( ch->pnote->to_list );
note.c:	ch->pnote->to_list = str_dup( argument );
note.c:	if ( ch->pnote != NULL )
note.c:	    free_note(ch->pnote);
note.c:	    ch->pnote = NULL;
note.c:	if ( ch->pnote == NULL )
note.c:	if (ch->pnote->type != type)
note.c:	    ch->pnote->sender,
note.c:	    ch->pnote->subject,
note.c:	    ch->pnote->to_list
note.c:	send_to_char( ch->pnote->text, ch );
note.c:	if ( ch->pnote == NULL )
note.c:        if (ch->pnote->type != type)
note.c:	if (!str_cmp(ch->pnote->to_list,""))
note.c:	if (!str_cmp(ch->pnote->subject,""))
note.c:	ch->pnote->next			= NULL;
note.c:	ch->pnote->date			= str_dup( strtime );
note.c:	ch->pnote->date_stamp		= current_time;
note.c:	append_note(ch->pnote);
note.c:	ch->pnote = NULL;
recycle.c:    ch->name                    = &str_empty[0];
recycle.c:    ch->short_descr             = &str_empty[0];
recycle.c:    ch->long_descr              = &str_empty[0];
recycle.c:    ch->description             = &str_empty[0];
recycle.c:    ch->prompt                  = &str_empty[0];
recycle.c:    ch->prefix			= &str_empty[0];
recycle.c:    ch->logon                   = current_time;
recycle.c:    ch->lines                   = PAGELEN;
recycle.c:      ch->armor[i]              = 100;
recycle.c:    ch->position                = POS_STANDING;
recycle.c:    ch->hit                     = 20;
recycle.c:    ch->max_hit                 = 20;
recycle.c:    ch->mana                    = 100;
recycle.c:    ch->max_mana                = 100;
recycle.c:    ch->move                    = 100;
recycle.c:    ch->max_move                = 100;
recycle.c:        ch->perm_stat[i] = 13;
recycle.c:        ch->mod_stat[i] = 0;
recycle.c:    for (obj = ch->carrying; obj != NULL; obj = obj_next)
recycle.c:    for (paf = ch->affected; paf != NULL; paf = paf_next)
recycle.c:    free_string(ch->name);
recycle.c:    free_string(ch->short_descr);
recycle.c:    free_string(ch->long_descr);
recycle.c:    free_string(ch->description);
recycle.c:    free_string(ch->prompt);
recycle.c:    free_string(ch->prefix);
recycle.c:    free_note  (ch->pnote);
recycle.c:    free_pcdata(ch->pcdata);
recycle.c:    ch->next = char_free;
religion.c:    if ( ch->religion)
religion.c:	      (god_table[ch->religion].name),(god_table[ch->religion].name) );
religion.c:    if ( ch->alignment < god_table[god].min_align )
religion.c:      if ( ch->alignment < ( god_table[god].min_align - 500 ) )
religion.c:    if ( ch->alignment > god_table[god].max_align )
religion.c:      if ( ch->alignment > ( god_table[god].max_align + 500 ) )
religion.c:    ch->religion = god;
religion.c:    if ( (ch->in_room->vnum == god_table[god].temple) ||
religion.c:	 (ch->class = class_lookup("cleric"))         ||
religion.c:	 (ch->class = class_lookup("priest")) )
religion.c:    if ( ch->religion == 0 )
religion.c:	if ( ch->in_room->vnum == god_table[god].temple )
religion.c:      sprintf( buf, "You worship %s.\n\r",(god_table[ch->religion].name));
religion.c:  if ( !ch->religion )
religion.c:    if ( ch->religion != god )
religion.c:	      (god_table[ch->religion].name),(god_table[god].name) );
religion.c:      ch->religion = 0;
remort.c:    if ( IS_NPC(ch) || ( d = ch->desc ) == NULL )
remort.c:    if ( (ch->level > LEVEL_HERO) || (ch->pcdata->incarnations > 2) )
remort.c:    if ( ch->level < LEVEL_HERO )
remort.c:    if ( ch->pcdata->confirm_remort )
remort.c:	    ch->pcdata->confirm_remort = FALSE;
remort.c:	    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
remort.c:	    sprintf( player_name, "%s", capitalize( ch->name ) );
remort.c:	    sprintf( player_pwd, "%s", ch->pcdata->pwd );
remort.c:	    sex = ch->pcdata->true_sex;
remort.c:	    sprintf( short_descr, "%s", ch->short_descr );
remort.c:	    sprintf( long_descr,  "%s", ch->long_descr  );
remort.c:	    sprintf( description, "%s", ch->description );
remort.c:	    sprintf( prompt,      "%s", ch->prompt      );
remort.c:	    religion = ch->religion;
remort.c:	    class  = ch->class;
remort.c:	    race   = ch->race;
remort.c:	    played = ch->played;
remort.c:	    player_incarnations = ++ch->pcdata->incarnations;
remort.c:	    if( !IS_SET( ch->act, PLR_REMORT ) )
remort.c:		SET_BIT( ch->act, PLR_REMORT );
remort.c:    ch->pcdata->confirm_remort = TRUE;
save.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
save.c:	ch = ch->desc->original;
save.c:    if (IS_IMMORTAL(ch) || ch->level >= LEVEL_IMMORTAL)
save.c:	sprintf(strsave, "%s%s",GOD_DIR, capitalize(ch->name));
save.c:	    ch->level, get_trust(ch), ch->name, ch->pcdata->title);
save.c:    sprintf( strsave, "%s%s", PLAYER_DIR, capitalize( ch->name ) );
save.c:	if ( ch->carrying != NULL )
save.c:	    fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:	if (ch->pet != NULL && ch->pet->in_room == ch->in_room)
save.c:	    fwrite_pet(ch->pet,fp);
save.c:    fprintf( fp, "Name %s~\n",	ch->name		);
save.c:    fprintf( fp, "Id   %ld\n", ch->id			);
save.c:    if (ch->short_descr[0] != '\0')
save.c:      	fprintf( fp, "ShD  %s~\n",	ch->short_descr	);
save.c:    if( ch->long_descr[0] != '\0')
save.c:	fprintf( fp, "LnD  %s~\n",	ch->long_descr	);
save.c:    if (ch->description[0] != '\0')
save.c:    	fprintf( fp, "Desc %s~\n",	ch->description	);
save.c:    if (ch->prompt != NULL || !str_cmp(ch->prompt,"<%hhp %mm %vmv> "))
save.c:        fprintf( fp, "Prom %s~\n",      ch->prompt  	);
save.c:    fprintf( fp, "Race %s~\n", pc_race_table[ch->race].name );
save.c:    if (ch->clan)
save.c:    	fprintf( fp, "Clan %s~\n",clan_table[ch->clan].name);
save.c:    fprintf( fp, "Religion %s~\n",god_table[ch->religion].name );
save.c:    fprintf( fp, "Sex  %d\n",	ch->sex			);
save.c:    fprintf( fp, "Cla  %d\n",	ch->class		);
save.c:    fprintf( fp, "Levl %d\n",	ch->level		);
save.c:    if (ch->trust != 0)
save.c:	fprintf( fp, "Tru  %d\n",	ch->trust	);
save.c:	ch->played + (int) (current_time - ch->logon)	);
save.c:	ch->pcdata->last_note,ch->pcdata->last_idea,ch->pcdata->last_penalty,
save.c:	ch->pcdata->last_news,ch->pcdata->last_changes	);
save.c:    fprintf( fp, "Scro %d\n", 	ch->lines		);
save.c:        (  ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:        && ch->was_in_room != NULL )
save.c:            ? ch->was_in_room->vnum
save.c:            : ch->in_room == NULL ? 3001 : ch->in_room->vnum );
save.c:	ch->hit, ch->max_hit, ch->mana, ch->max_mana, ch->move, ch->max_move );
save.c:    if (ch->gold > 0)
save.c:      fprintf( fp, "Gold %ld\n",	ch->gold		);
save.c:    if (ch->silver > 0)
save.c:	fprintf( fp, "Silv %ld\n",ch->silver		);
save.c:    fprintf( fp, "Exp  %d\n",	ch->exp			);
save.c:    if (ch->act != 0)
save.c:	fprintf( fp, "Act  %s\n",   print_flags(ch->act));
save.c:    if (ch->affected_by != 0)
save.c:	fprintf( fp, "AfBy %s\n",   print_flags(ch->affected_by));
save.c:    fprintf( fp, "Comm %s\n",       print_flags(ch->comm));
save.c:    if (ch->wiznet)
save.c:    	fprintf( fp, "Wizn %s\n",   print_flags(ch->wiznet));
save.c:    if (ch->invis_level)
save.c:	fprintf( fp, "Invi %d\n", 	ch->invis_level	);
save.c:    if (ch->incog_level)
save.c:	fprintf(fp,"Inco %d\n",ch->incog_level);
save.c:	ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    if (ch->practice != 0)
save.c:    	fprintf( fp, "Prac %d\n",	ch->practice	);
save.c:    if (ch->train != 0)
save.c:	fprintf( fp, "Trai %d\n",	ch->train	);
save.c:    if (ch->saving_throw != 0)
save.c:	fprintf( fp, "Save  %d\n",	ch->saving_throw);
save.c:    fprintf( fp, "Alig  %d\n",	ch->alignment		);
save.c:    if (ch->hitroll != 0)
save.c:	fprintf( fp, "Hit   %d\n",	ch->hitroll	);
save.c:    if (ch->damroll != 0)
save.c:	fprintf( fp, "Dam   %d\n",	ch->damroll	);
save.c:	ch->armor[0],ch->armor[1],ch->armor[2],ch->armor[3]);
save.c:    if (ch->wimpy !=0 )
save.c:	fprintf( fp, "Wimp  %d\n",	ch->wimpy	);
save.c:	ch->perm_stat[STAT_STR],
save.c:	ch->perm_stat[STAT_INT],
save.c:	ch->perm_stat[STAT_WIS],
save.c:	ch->perm_stat[STAT_DEX],
save.c:	ch->perm_stat[STAT_CON] );
save.c:	ch->mod_stat[STAT_STR],
save.c:	ch->mod_stat[STAT_INT],
save.c:	ch->mod_stat[STAT_WIS],
save.c:	ch->mod_stat[STAT_DEX],
save.c:	ch->mod_stat[STAT_CON] );
save.c:	fprintf( fp, "Vnum %d\n",	ch->pIndexData->vnum	);
save.c:	fprintf( fp, "Pass %s~\n",	ch->pcdata->pwd		);
save.c:	if (ch->pcdata->bamfin[0] != '\0')
save.c:	    fprintf( fp, "Bin  %s~\n",	ch->pcdata->bamfin);
save.c:	if (ch->pcdata->bamfout[0] != '\0')
save.c:		fprintf( fp, "Bout %s~\n",	ch->pcdata->bamfout);
save.c:	fprintf( fp, "Titl %s~\n",	ch->pcdata->title	);
save.c:    	fprintf( fp, "Pnts %d\n",   	ch->pcdata->points      );
save.c:	fprintf( fp, "TSex %d\n",	ch->pcdata->true_sex	);
save.c:	fprintf( fp, "LLev %d\n",	ch->pcdata->last_level	);
save.c:	fprintf( fp, "HMVP %d %d %d\n", ch->pcdata->perm_hit, 
save.c:						   ch->pcdata->perm_mana,
save.c:						   ch->pcdata->perm_move);
save.c:	    ch->pcdata->condition[0],
save.c:	    ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2],
save.c:	    ch->pcdata->condition[3] );
save.c:		 ch->pcdata->incarnations );
save.c:	    if (ch->pcdata->alias[pos] == NULL
save.c:	    ||  ch->pcdata->alias_sub[pos] == NULL)
save.c:	    fprintf(fp,"Alias %s %s~\n",ch->pcdata->alias[pos],
save.c:		    ch->pcdata->alias_sub[pos]);
save.c:	    if ( skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0 )
save.c:		    ch->pcdata->learned[sn], skill_table[sn].name );
save.c:            if ( group_table[gn].name != NULL && ch->pcdata->group_known[gn])
save.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
save.c:    if ( (ch->level < obj->level - 2 && obj->item_type != ITEM_CONTAINER)
save.c:    ch->pcdata = new_pcdata();
save.c:    ch->desc				= d;
save.c:    ch->name				= str_dup( name );
save.c:    ch->id				= get_pc_id();
save.c:    ch->race				= race_lookup("human");
save.c:    ch->religion                        = 0;
save.c:    ch->act				= PLR_NOSUMMON;
save.c:    ch->comm				= COMM_COMBINE 
save.c:    ch->prompt 				= str_dup("<%hhp %mm %vmv> ");
save.c:    ch->pcdata->confirm_delete		= FALSE;
save.c:    ch->pcdata->pwd			= str_dup( "" );
save.c:    ch->pcdata->bamfin			= str_dup( "" );
save.c:    ch->pcdata->bamfout			= str_dup( "" );
save.c:    ch->pcdata->title			= str_dup( "" );
save.c:	ch->perm_stat[stat]		= 13;
save.c:    ch->pcdata->condition[COND_THIRST]	= 48; 
save.c:    ch->pcdata->condition[COND_FULL]	= 48;
save.c:    ch->pcdata->condition[COND_HUNGER]	= 48;
save.c:    ch->pcdata->incarnations		= 1;
save.c:	if (ch->race == 0)
save.c:	    ch->race = race_lookup("human");
save.c:	ch->size = pc_race_table[ch->race].size;
save.c:	ch->dam_type = 17; /*punch */
save.c:	    if (pc_race_table[ch->race].skills[i] == NULL)
save.c:	    group_add(ch,pc_race_table[ch->race].skills[i],FALSE);
save.c:	ch->affected_by = ch->affected_by|race_table[ch->race].aff;
save.c:	ch->imm_flags	= ch->imm_flags | race_table[ch->race].imm;
save.c:	ch->res_flags	= ch->res_flags | race_table[ch->race].res;
save.c:	ch->vuln_flags	= ch->vuln_flags | race_table[ch->race].vuln;
save.c:	ch->form	= race_table[ch->race].form;
save.c:	ch->parts	= race_table[ch->race].parts;
save.c:    if (found && ch->version < 2)  /* need to add the new skills */
save.c:	group_add(ch,class_table[ch->class].base_group,FALSE);
save.c:	group_add(ch,class_table[ch->class].default_group,TRUE);
save.c:	ch->pcdata->learned[gsn_recall] = 50;
save.c:    if (found && ch->version < 3 && (ch->level > 35 || ch->trust > 35))
save.c:	switch (ch->level)
save.c:	    case(40) : ch->level = 60;	break;  /* imp -> imp */
save.c:	    case(39) : ch->level = 58; 	break;	/* god -> supreme */
save.c:	    case(38) : ch->level = 56;  break;	/* deity -> god */
save.c:	    case(37) : ch->level = 53;  break;	/* angel -> demigod */
save.c:        switch (ch->trust)
save.c:            case(40) : ch->trust = 60;  break;	/* imp -> imp */
save.c:            case(39) : ch->trust = 58;  break;	/* god -> supreme */
save.c:            case(38) : ch->trust = 56;  break;	/* deity -> god */
save.c:            case(37) : ch->trust = 53;  break;	/* angel -> demigod */
save.c:            case(36) : ch->trust = 51;  break;	/* hero -> hero */
save.c:    if (found && ch->version < 4)
save.c:	ch->gold   /= 100;
save.c:    sprintf(buf,"Loading %s.",ch->name);
save.c:	    KEY( "Act",		ch->act,		fread_flag( fp ) );
save.c:	    KEY( "AffectedBy",	ch->affected_by,	fread_flag( fp ) );
save.c:	    KEY( "AfBy",	ch->affected_by,	fread_flag( fp ) );
save.c:	    KEY( "Alignment",	ch->alignment,		fread_number( fp ) );
save.c:	    KEY( "Alig",	ch->alignment,		fread_number( fp ) );
save.c:		ch->pcdata->alias[count] 	= str_dup(fread_word(fp));
save.c:		ch->pcdata->alias_sub[count]	= str_dup(fread_word(fp));
save.c:                ch->pcdata->alias[count]        = str_dup(fread_word(fp));
save.c:                ch->pcdata->alias_sub[count]    = fread_string(fp);
save.c:		    ch->armor[i] = fread_number(fp);
save.c:		paf->next	= ch->affected;
save.c:		ch->affected	= paf;
save.c:                paf->next       = ch->affected;
save.c:                ch->affected    = paf;
save.c:		   ch->mod_stat[stat] = fread_number(fp);
save.c:		    ch->perm_stat[stat] = fread_number(fp);
save.c:	    KEY( "Bamfin",	ch->pcdata->bamfin,	fread_string( fp ) );
save.c:	    KEY( "Bamfout",	ch->pcdata->bamfout,	fread_string( fp ) );
save.c:	    KEY( "Bin",		ch->pcdata->bamfin,	fread_string( fp ) );
save.c:	    KEY( "Bout",	ch->pcdata->bamfout,	fread_string( fp ) );
save.c:	    KEY( "Class",	ch->class,		fread_number( fp ) );
save.c:	    KEY( "Cla",		ch->class,		fread_number( fp ) );
save.c:	    KEY( "Clan",	ch->clan,	clan_lookup(fread_string(fp)));
save.c:		ch->pcdata->condition[0] = fread_number( fp );
save.c:		ch->pcdata->condition[1] = fread_number( fp );
save.c:		ch->pcdata->condition[2] = fread_number( fp );
save.c:                ch->pcdata->condition[0] = fread_number( fp );
save.c:                ch->pcdata->condition[1] = fread_number( fp );
save.c:                ch->pcdata->condition[2] = fread_number( fp );
save.c:		ch->pcdata->condition[3] = fread_number( fp );
save.c:	    KEY("Comm",		ch->comm,		fread_flag( fp ) ); 
save.c:	    KEY( "Damroll",	ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Dam",		ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Description",	ch->description,	fread_string( fp ) );
save.c:	    KEY( "Desc",	ch->description,	fread_string( fp ) );
save.c:        	    ch->hit	+= (ch->max_hit - ch->hit) * percent / 100;
save.c:        	    ch->mana    += (ch->max_mana - ch->mana) * percent / 100;
save.c:        	    ch->move    += (ch->max_move - ch->move)* percent / 100;
save.c:	    KEY( "Exp",		ch->exp,		fread_number( fp ) );
save.c:	    KEY( "Gold",	ch->gold,		fread_number( fp ) );
save.c:	    KEY( "Hitroll",	ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Hit",		ch->hitroll,		fread_number( fp ) );
save.c:		ch->hit		= fread_number( fp );
save.c:		ch->max_hit	= fread_number( fp );
save.c:		ch->mana	= fread_number( fp );
save.c:		ch->max_mana	= fread_number( fp );
save.c:		ch->move	= fread_number( fp );
save.c:		ch->max_move	= fread_number( fp );
save.c:                ch->pcdata->perm_hit	= fread_number( fp );
save.c:                ch->pcdata->perm_mana   = fread_number( fp );
save.c:                ch->pcdata->perm_move   = fread_number( fp );
save.c:	    KEY( "Incr",	ch->pcdata->incarnations, fread_number(fp) );
save.c:	    KEY( "Id",		ch->id,			fread_number( fp ) );
save.c:	    KEY( "InvisLevel",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "Inco",	ch->incog_level,	fread_number( fp ) );
save.c:	    KEY( "Invi",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "LastLevel",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "LLev",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "Level",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "Lev",		ch->level,		fread_number( fp ) );
save.c:	    KEY( "Levl",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "LongDescr",	ch->long_descr,		fread_string( fp ) );
save.c:	    KEY( "LnD",		ch->long_descr,		fread_string( fp ) );
save.c:	    KEYS( "Name",	ch->name,		fread_string( fp ) );
save.c:	    KEY( "Note",	ch->pcdata->last_note,	fread_number( fp ) );
save.c:		ch->pcdata->last_note			= fread_number(fp);
save.c:		ch->pcdata->last_idea			= fread_number(fp);
save.c:		ch->pcdata->last_penalty		= fread_number(fp);
save.c:		ch->pcdata->last_news			= fread_number(fp);
save.c:		ch->pcdata->last_changes		= fread_number(fp);
save.c:	    KEY( "Password",	ch->pcdata->pwd,	fread_string( fp ) );
save.c:	    KEY( "Pass",	ch->pcdata->pwd,	fread_string( fp ) );
save.c:	    KEY( "Played",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Plyd",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Points",	ch->pcdata->points,	fread_number( fp ) );
save.c:	    KEY( "Pnts",	ch->pcdata->points,	fread_number( fp ) );
save.c:	    KEY( "Position",	ch->position,		fread_number( fp ) );
save.c:	    KEY( "Pos",		ch->position,		fread_number( fp ) );
save.c:	    KEY( "Practice",	ch->practice,		fread_number( fp ) );
save.c:	    KEY( "Prac",	ch->practice,		fread_number( fp ) );
save.c:            KEYS( "Prompt",      ch->prompt,             fread_string( fp ) );
save.c: 	    KEY( "Prom",	ch->prompt,		fread_string( fp ) );
save.c:	    KEY( "Race",        ch->race,	
save.c:	    KEY( "Religion",    ch->religion,
save.c:		ch->in_room = get_room_index( fread_number( fp ) );
save.c:		if ( ch->in_room == NULL )
save.c:		    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:	    KEY( "SavingThrow",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Save",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Scro",	ch->lines,		fread_number( fp ) );
save.c:	    KEY( "Sex",		ch->sex,		fread_number( fp ) );
save.c:	    KEY( "ShortDescr",	ch->short_descr,	fread_string( fp ) );
save.c:	    KEY( "ShD",		ch->short_descr,	fread_string( fp ) );
save.c:            KEY( "Silv",        ch->silver,             fread_number( fp ) );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:            KEY( "TrueSex",     ch->pcdata->true_sex,  	fread_number( fp ) );
save.c:	    KEY( "TSex",	ch->pcdata->true_sex,   fread_number( fp ) );
save.c:	    KEY( "Trai",	ch->train,		fread_number( fp ) );
save.c:	    KEY( "Trust",	ch->trust,		fread_number( fp ) );
save.c:	    KEY( "Tru",		ch->trust,		fread_number( fp ) );
save.c:		ch->pcdata->title = fread_string( fp );
save.c:    		if (ch->pcdata->title[0] != '.' && ch->pcdata->title[0] != ',' 
save.c:		&&  ch->pcdata->title[0] != '!' && ch->pcdata->title[0] != '?')
save.c:		    sprintf( buf, " %s", ch->pcdata->title );
save.c:		    free_string( ch->pcdata->title );
save.c:		    ch->pcdata->title = str_dup( buf );
save.c:	    KEY( "Version",     ch->version,		fread_number ( fp ) );
save.c:	    KEY( "Vers",	ch->version,		fread_number ( fp ) );
save.c:		ch->pIndexData = get_mob_index( fread_number( fp ) );
save.c:	    KEY( "Wimpy",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "Wimp",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "Wizn",	ch->wiznet,		fread_flag( fp ) );
save.c:		ch->pet = pet;
scan.c:                scan_list(ch->in_room, ch, 0, -1);
scan.c:   scan_room = ch->in_room;
scan.c:   for (rch=scan_room->people; rch != NULL; rch=rch->next_in_room)
scan.c:      if (!IS_NPC(rch) && rch->invis_level > get_trust(ch)) continue;
skills.c:    for ( trainer = ch->in_room->people; 
skills.c:	    if (!ch->pcdata->group_known[gn]
skills.c:	    &&  group_table[gn].rating[ch->class] > 0)
skills.c:		    group_table[gn].name,group_table[gn].rating[ch->class]);
skills.c:            if (!ch->pcdata->learned[sn]
skills.c:            &&  skill_table[sn].rating[ch->class] > 0
skills.c:                    skill_table[sn].name,skill_table[sn].rating[ch->class]);
skills.c:	if (ch->practice < 10)
skills.c:	ch->practice -= 10;
skills.c:	ch->train +=1 ;
skills.c:	if (ch->train < 2)
skills.c:	if (ch->pcdata->points <= 40)
skills.c:	ch->train -= 2;
skills.c:	ch->pcdata->points -= 1;
skills.c:	ch->exp = exp_per_level(ch,ch->pcdata->points) * ch->level;
skills.c:	if (ch->pcdata->group_known[gn])
skills.c:	if (group_table[gn].rating[ch->class] <= 0)
skills.c:	if (ch->train < group_table[gn].rating[ch->class])
skills.c:	ch->train -= group_table[gn].rating[ch->class];
skills.c:        if (ch->pcdata->learned[sn])
skills.c:        if (skill_table[sn].rating[ch->class] <= 0)
skills.c:        if (ch->train < skill_table[sn].rating[ch->class])
skills.c:	ch->pcdata->learned[sn] = 1;
skills.c:        ch->train -= skill_table[sn].rating[ch->class];
skills.c:	if ((level = skill_table[sn].skill_level[ch->class]) < LEVEL_HERO + 1
skills.c:	&&  (fAll || level <= ch->level)
skills.c:	&&  ch->pcdata->learned[sn] > 0)
skills.c:	    level = skill_table[sn].skill_level[ch->class];
skills.c:	    if (ch->level < level)
skills.c:		    100/(2 + ch->level - level));
skills.c:      if ((level = skill_table[sn].skill_level[ch->class]) < LEVEL_HERO + 1
skills.c:	  &&  (fAll || level <= ch->level)
skills.c:	  &&  ch->pcdata->learned[sn] > 0)
skills.c:	level = skill_table[sn].skill_level[ch->class];
skills.c:	if (ch->level < level)
skills.c:		  ch->pcdata->learned[sn]);
skills.c:        if (!ch->gen_data->group_chosen[gn] 
skills.c:	&&  !ch->pcdata->group_known[gn]
skills.c:	&&  group_table[gn].rating[ch->class] > 0)
skills.c:				    group_table[gn].rating[ch->class]);
skills.c:        if (!ch->gen_data->skill_chosen[sn] 
skills.c:	&&  ch->pcdata->learned[sn] == 0
skills.c:	&&  skill_table[sn].rating[ch->class] > 0)
skills.c:                                    skill_table[sn].rating[ch->class]);
skills.c:    sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
skills.c:	    exp_per_level(ch,ch->gen_data->points_chosen));
skills.c:        if (ch->gen_data->group_chosen[gn] 
skills.c:	&&  group_table[gn].rating[ch->class] > 0)
skills.c:                                    group_table[gn].rating[ch->class]);
skills.c:        if (ch->gen_data->skill_chosen[sn] 
skills.c:	&&  skill_table[sn].rating[ch->class] > 0)
skills.c:                                    skill_table[sn].rating[ch->class]);
skills.c:    sprintf(buf,"Creation points: %d\n\r",ch->gen_data->points_chosen);
skills.c:	    exp_per_level(ch,ch->gen_data->points_chosen));
skills.c:	return 1000 * (pc_race_table[ch->race].class_mult[ch->class] ?
skills.c:		       pc_race_table[ch->race].class_mult[ch->class]/100 : 1);
skills.c:    return expl * pc_race_table[ch->race].class_mult[ch->class]/100;
skills.c:	    if (ch->gen_data->group_chosen[gn]
skills.c:	    ||  ch->pcdata->group_known[gn])
skills.c:	    if (group_table[gn].rating[ch->class] < 1)
skills.c:	    if (ch->gen_data->points_chosen + group_table[gn].rating[ch->class]
skills.c:	    ch->gen_data->group_chosen[gn] = TRUE;
skills.c:	    ch->gen_data->points_chosen += group_table[gn].rating[ch->class];
skills.c:	    ch->pcdata->points += group_table[gn].rating[ch->class];
skills.c:	    if (ch->gen_data->skill_chosen[sn]
skills.c:	    ||  ch->pcdata->learned[sn] > 0)
skills.c:	    if (skill_table[sn].rating[ch->class] < 1
skills.c:	    if (ch->gen_data->points_chosen + skill_table[sn].rating[ch->class]
skills.c:	    ch->gen_data->skill_chosen[sn] = TRUE;
skills.c:	    ch->gen_data->points_chosen += skill_table[sn].rating[ch->class];
skills.c:	    ch->pcdata->learned[sn] = 1;
skills.c:	    ch->pcdata->points += skill_table[sn].rating[ch->class];
skills.c:	if (gn != -1 && ch->gen_data->group_chosen[gn])
skills.c:	    ch->gen_data->group_chosen[gn] = FALSE;
skills.c:	    ch->gen_data->points_chosen -= group_table[gn].rating[ch->class];
skills.c:		if (ch->gen_data->group_chosen[gn])
skills.c:	    ch->pcdata->points -= group_table[gn].rating[ch->class];
skills.c:	if (sn != -1 && ch->gen_data->skill_chosen[sn])
skills.c:	    ch->gen_data->skill_chosen[sn] = FALSE;
skills.c:	    ch->gen_data->points_chosen -= skill_table[sn].rating[ch->class];
skills.c:	    ch->pcdata->learned[sn] = 0;
skills.c:	    ch->pcdata->points -= skill_table[sn].rating[ch->class];
skills.c:	    if (ch->pcdata->group_known[gn])
skills.c:        sprintf(buf,"Creation points: %d\n\r",ch->pcdata->points);
skills.c:    if (ch->level < skill_table[sn].skill_level[ch->class]
skills.c:    ||  skill_table[sn].rating[ch->class] == 0
skills.c:    ||  ch->pcdata->learned[sn] == 0
skills.c:    ||  ch->pcdata->learned[sn] == 100)
skills.c:		*	skill_table[sn].rating[ch->class] 
skills.c:    chance += ch->level;
skills.c:	chance = URANGE(5,100 - ch->pcdata->learned[sn], 95);
skills.c:	    ch->pcdata->learned[sn]++;
skills.c:	    gain_exp(ch,2 * skill_table[sn].rating[ch->class]);
skills.c:	chance = URANGE(5,ch->pcdata->learned[sn]/2,30);
skills.c:	    ch->pcdata->learned[sn] += number_range(1,3);
skills.c:	    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
skills.c:	    gain_exp(ch,2 * skill_table[sn].rating[ch->class]);
skills.c:    ch->pcdata->group_known[gn] = TRUE;
skills.c:    ch->pcdata->group_known[gn] = FALSE;
skills.c:    if (ch->pcdata->learned[sn] == 0) /* i.e. not known */
skills.c:      ch->pcdata->learned[sn] = 1;
skills.c:	ch->pcdata->points += skill_table[sn].rating[ch->class]; 
skills.c:    if (ch->pcdata->group_known[gn] == FALSE)  
skills.c:      ch->pcdata->group_known[gn] = TRUE;
skills.c:	ch->pcdata->points += group_table[gn].rating[ch->class];
skills.c:	ch->pcdata->learned[sn] = 0;
skills.c:    if (gn != -1 && ch->pcdata->group_known[gn] == TRUE)
skills.c:	ch->pcdata->group_known[gn] = FALSE;
special.c:    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL 
special.c:    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
special.c:    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
special.c:	if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
special.c:	if (vch->pIndexData->group == GROUP_VNUM_OGRES
special.c:	&&  ch->level > vch->level - 2 && !is_safe(ch,vch))
special.c:    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL
special.c:    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
special.c:    for (vch = ch->in_room->people;  vch != NULL;  vch = vch->next_in_room)
special.c:        if (vch->pIndexData->vnum == MOB_VNUM_PATROLMAN)
special.c:        if (vch->pIndexData->group == GROUP_VNUM_TROLLS
special.c:        &&  ch->level > vch->level - 2 && !is_safe(ch,vch))
special.c:    if (!IS_AWAKE(ch) || IS_AFFECTED(ch,AFF_CALM) || ch->in_room == NULL
special.c:    ||  IS_AFFECTED(ch,AFF_CHARM) || ch->fighting != NULL)
special.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
special.c:	if (vch->fighting != NULL)  /* break it up! */
special.c:	        victim = (vch->level > vch->fighting->level) 
special.c:		    ? vch : vch->fighting;
special.c:    if (victim == NULL || (IS_NPC(victim) && victim->spec_fun == ch->spec_fun))
special.c:    	for ( vch = char_list; vch != NULL; vch = vch->next )
special.c:            if ( vch->in_room == NULL )
special.c:            if (vch->in_room != ch->in_room 
special.c:	    &&  vch->in_room->area == ch->in_room->area)
special.c:    if (ch->position != POS_FIGHTING) {
special.c:       for ( victim = ch->in_room->people; victim != NULL; victim = v_next)
special.c:             && (victim->level > ch->level)
special.c:             && (victim->level < ch->level + 10))
special.c:             if (ch->position != POS_FIGHTING)
special.c:    if ( (victim = ch->fighting) == NULL)
special.c:                 ch->gold     += gold;
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim, TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, NULL,TARGET_CHAR);
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	spell_armor( skill_lookup( "armor" ), ch->level,ch,victim,TARGET_CHAR);
special.c:	spell_bless( skill_lookup( "bless" ), ch->level,ch,victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	    ch->level, ch, victim,TARGET_CHAR);
special.c:	spell_refresh( skill_lookup("refresh"),ch->level,ch,victim,TARGET_CHAR);
special.c:	    ch->level,ch,victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    REMOVE_BIT(ch->comm,COMM_NOSHOUT);
special.c:    for ( corpse = ch->in_room->contents; corpse != NULL; corpse = c_next )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c: 	REMOVE_BIT(ch->comm,COMM_NOSHOUT);
special.c:    for ( trash = ch->in_room->contents; trash != NULL; trash = trash_next )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:	ch->position = POS_STANDING;
special.c:	ch->position = POS_SLEEPING;
special.c:    if ( ch->position != POS_FIGHTING
special.c:    || ( victim = ch->fighting ) == NULL
special.c:    ||   number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim,TARGET_CHAR);
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( IS_AWAKE(victim) && number_range( 0, ch->level ) == 0 )
special.c:	    gold = victim->gold * UMIN(number_range(1,20),ch->level / 2) / 100;
special.c:	    gold = UMIN(gold, ch->level * ch->level * 10 );
special.c:	    ch->gold     += gold;
special.c:	    silver = victim->silver * UMIN(number_range(1,20),ch->level/2)/100;
special.c:	    silver = UMIN(silver,ch->level*ch->level * 25);
special.c:	    ch->silver	+= silver;
update.c:    ch->pcdata->last_level = 
update.c:	( ch->played + (int) (current_time - ch->logon) ) / 3600;
update.c:	title_table [ch->class] [ch->level] [ch->sex == SEX_FEMALE ? 1 : 0] );
update.c:		    class_table[ch->class].hp_min,
update.c:		    class_table[ch->class].hp_max );
update.c:    if (!class_table[ch->class].fMana)
update.c:    ch->max_hit 	+= add_hp;
update.c:    ch->max_mana	+= add_mana;
update.c:    ch->max_move	+= add_move;
update.c:    ch->practice	+= add_prac;
update.c:    ch->train		+= 1;
update.c:    ch->pcdata->perm_hit	+= add_hp;
update.c:    ch->pcdata->perm_mana	+= add_mana;
update.c:    ch->pcdata->perm_move	+= add_move;
update.c:    if ( IS_NPC(ch) || ch->level >= LEVEL_HERO )
update.c:    ch->exp = UMAX( exp_per_level(ch,ch->pcdata->points), ch->exp + gain );
update.c:    while ( ch->level < LEVEL_HERO && ch->exp >= 
update.c:	exp_per_level(ch,ch->pcdata->points) * (ch->level+1) )
update.c:	ch->level += 1;
update.c:	sprintf(buf,"%s gained level %d",ch->name,ch->level);
update.c:	sprintf(buf,"$N has attained level %d!",ch->level);
update.c:    if (ch->in_room == NULL)
update.c:	gain =  5 + ch->level;
update.c:	switch(ch->position)
update.c:      gain = UMAX(3,get_curr_stat(ch,STAT_CON) - 3 + ch->level/2); 
update.c:      gain += class_table[ch->class].hp_max - 10;
update.c:	if (ch->hit < ch->max_hit)
update.c:	if (ch->hit < ch->max_hit)
update.c:      switch ( ch->position )
update.c:      if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
update.c:      if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    gain = gain * ch->in_room->heal_rate / 100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[3] / 100;
update.c:    return UMIN(gain, ch->max_hit - ch->hit);
update.c:    if (ch->in_room == NULL)
update.c:	gain = 5 + ch->level;
update.c:	switch (ch->position)
update.c:	      + get_curr_stat(ch,STAT_INT) + ch->level) / 2;
update.c:	    if (ch->mana < ch->max_mana)
update.c:	if (!class_table[ch->class].fMana)
update.c:	  if (ch->mana < ch->max_mana)
update.c:	if (!class_table[ch->class].fMana)
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    gain = gain * ch->in_room->mana_rate / 100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[4] / 100;
update.c:    return UMIN(gain, ch->max_mana - ch->mana);
update.c:    if (ch->in_room == NULL)
update.c:	gain = ch->level;
update.c:	gain = UMAX( 15, ch->level );
update.c:	switch ( ch->position )
update.c:	if ( ch->pcdata->condition[COND_HUNGER]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:    gain = gain * ch->in_room->heal_rate/100;
update.c:    if (ch->on != NULL && ch->on->item_type == ITEM_FURNITURE)
update.c:	gain = gain * ch->on->value[3] / 100;
update.c:    return UMIN(gain, ch->max_move - ch->move);
update.c:    if ( value == 0 || IS_NPC(ch) || ch->level >= LEVEL_IMMORTAL)
update.c:    condition				= ch->pcdata->condition[iCond];
update.c:    ch->pcdata->condition[iCond]	= URANGE( 0, condition + value, 48 );
update.c:    if ( ch->pcdata->condition[iCond] == 0 )
update.c:	ch_next = ch->next;
update.c:	if ( !IS_NPC(ch) || ch->in_room == NULL || IS_AFFECTED(ch,AFF_CHARM))
update.c:	if (ch->in_room->area->empty && !IS_SET(ch->act,ACT_UPDATE_ALWAYS))
update.c:	if ( ch->spec_fun != 0 )
update.c:	    if ( (*ch->spec_fun) ( ch ) )
update.c:	if (ch->pIndexData->pShop != NULL) /* give him some gold */
update.c:	  if ((ch->gold * 100 + ch->silver) < ch->pIndexData->wealth)
update.c:	    ch->gold += ch->pIndexData->wealth * number_range(1,20)/5000000;
update.c:	    ch->silver += ch->pIndexData->wealth * number_range(1,20)/50000;
update.c:	if ( ch->position != POS_STANDING )
update.c:	if ( IS_SET(ch->act, ACT_SCAVENGER)
update.c:	&&   ch->in_room->contents != NULL
update.c:	    for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
update.c:	if ( !IS_SET(ch->act, ACT_SENTINEL) 
update.c:	&& ( pexit = ch->in_room->exit[door] ) != NULL
update.c:	&& ( !IS_SET(ch->act, ACT_STAY_AREA)
update.c:	||   pexit->u1.to_room->area == ch->in_room->area ) 
update.c:	&& ( !IS_SET(ch->act, ACT_OUTDOORS)
update.c:	&& ( !IS_SET(ch->act, ACT_INDOORS)
update.c:	ch_next = ch->next;
update.c:        if ( ch->timer > 30 )
update.c:	if ( ch->position >= POS_STUNNED )
update.c:            if (IS_NPC(ch) && ch->zone != NULL && ch->zone != ch->in_room->area
update.c:            && ch->desc == NULL &&  ch->fighting == NULL 
update.c:	    if ( ch->hit  < ch->max_hit )
update.c:		ch->hit  += hit_gain(ch);
update.c:		ch->hit = ch->max_hit;
update.c:	    if ( ch->mana < ch->max_mana )
update.c:		ch->mana += mana_gain(ch);
update.c:		ch->mana = ch->max_mana;
update.c:	    if ( ch->move < ch->max_move )
update.c:		ch->move += move_gain(ch);
update.c:		ch->move = ch->max_move;
update.c:	if ( ch->position == POS_STUNNED )
update.c:	if ( !IS_NPC(ch) && ch->level < LEVEL_IMMORTAL )
update.c:		if ( --obj->value[2] == 0 && ch->in_room != NULL )
update.c:		    --ch->in_room->light;
update.c:	 	else if ( obj->value[2] <= 5 && ch->in_room != NULL)
update.c:		ch->timer = 0;
update.c:	    if ( ++ch->timer >= 15 )
update.c:		if ( ch->was_in_room == NULL && ch->in_room != NULL )
update.c:		    ch->was_in_room = ch->in_room;
update.c:		    if ( ch->fighting != NULL )
update.c:		    if (ch->level > 1)
update.c:	    gain_condition( ch, COND_FULL, ch->size > SIZE_MEDIUM ? -4 : -2 );
update.c:	    gain_condition( ch, COND_HUNGER, ch->size > SIZE_MEDIUM ? -2 : -1);
update.c:	for ( paf = ch->affected; paf != NULL; paf = paf_next )
update.c:	    if (ch->in_room == NULL)
update.c:            for ( af = ch->affected; af != NULL; af = af->next )
update.c:            	REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
update.c:            for ( vch=ch->in_room->people; vch != NULL; vch=vch->next_in_room)
update.c:	    dam = UMIN(ch->level,af->level/5+1);
update.c:	    ch->mana -= dam;
update.c:	    ch->move -= dam;
update.c:	    poison = affect_find(ch->affected,gsn_poison);
update.c:	else if ( ch->position == POS_INCAP && number_range(0,1) == 0)
update.c:	else if ( ch->position == POS_MORTAL )
update.c:        ch_next = ch->next;
update.c:	if (ch->desc != NULL && ch->desc->descriptor % 30 == save_number)
update.c:	wch_next = wch->next;
update.c:	||   wch->level >= LEVEL_IMMORTAL
update.c:	||   wch->in_room == NULL 
update.c:	||   wch->in_room->area->empty)
update.c:	for ( ch = wch->in_room->people; ch != NULL; ch = ch_next )
update.c:	    ch_next	= ch->next_in_room;
update.c:	    ||   !IS_SET(ch->act, ACT_AGGRESSIVE)
update.c:	    ||   IS_SET(ch->in_room->room_flags,ROOM_SAFE)
update.c:	    ||   ch->fighting != NULL
update.c:	    ||   ( IS_SET(ch->act, ACT_WIMPY) && IS_AWAKE(wch) )
update.c:	    for ( vch = wch->in_room->people; vch != NULL; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		&&   vch->level < LEVEL_IMMORTAL
update.c:		&&   ch->level >= vch->level - 5 
update.c:		&&   ( !IS_SET(ch->act, ACT_WIMPY) || !IS_AWAKE(vch) )
